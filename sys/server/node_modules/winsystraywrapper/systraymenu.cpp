
#include "systraymenu.h"

CSysTrayMenu* CSysTrayMenu::m_pSoleInstance = NULL;

CSysTrayMenu::CSysTrayMenu()
	: m_hMenu(NULL)
	, m_hWndMain(NULL)
	, m_dwWrappedProcessID(0)
{
	::memset(&m_icon, 0, sizeof(NOTIFYICONDATA));

	_ASSERT(m_pSoleInstance == NULL);
	m_pSoleInstance = this;
}

CSysTrayMenu::~CSysTrayMenu()
{
	m_pSoleInstance = NULL;
}

bool CSysTrayMenu::Init(const CString& sIconPath, const CString& sTitle, DWORD dwWrappedProcessID)
{
	m_dwWrappedProcessID = dwWrappedProcessID;

	HINSTANCE hInstance = ::GetModuleHandle(NULL);
	TCHAR szClassName[] = _T( "SysTrayWrapper" );

	::EnumWindows(EnumWindowsCallback, NULL);

	if (m_hWndMain)
	{
		::SetWindowText(m_hWndMain, sTitle);

		// Get system menu of our main window
		HMENU hMenuSys = ::GetSystemMenu(m_hWndMain, 0);

		// Disable the close button
		::EnableMenuItem(hMenuSys, SC_CLOSE, MF_DISABLED);
	}

	WNDCLASSEX wnd;
	memset(&wnd, 0, sizeof(WNDCLASSEX));

	wnd.hInstance = hInstance;
	wnd.lpszClassName = szClassName;
	wnd.lpfnWndProc = WndProc;
	wnd.cbSize = sizeof (WNDCLASSEX);

	int nrc = ::RegisterClassEx(&wnd);

	if (nrc == 0)
	{
		CString sMsg;
		sMsg.Format("RegisterClassEx failed, error %d", GetLastError());
		ThrowException(Exception::Error(String::New(sMsg)));
		return false;
	}

	HWND hWnd = ::CreateWindowEx(0, szClassName, "Task bar wrapper", WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, 100, 100, NULL, NULL, hInstance, NULL);

	if (hWnd == NULL)
	{
		CString sMsg;
		sMsg.Format("CreateWindowEx failed, error %d", GetLastError());
		ThrowException(Exception::Error(String::New(sMsg)));
		return false;
	}

	m_icon.cbSize = sizeof(NOTIFYICONDATA);

	m_icon.hWnd = hWnd;
	m_icon.uID = 5000;
	m_icon.uFlags = NIF_ICON | NIF_MESSAGE | NIF_TIP;
	m_icon.uCallbackMessage = WM_USER;
	m_icon.hIcon = (HICON)LoadImage( NULL, sIconPath, IMAGE_ICON, 0, 0, LR_LOADFROMFILE  ) ;
	strcpy(m_icon.szTip, sTitle);

	return true;
}

void CSysTrayMenu::Run()
{
	::Shell_NotifyIcon(NIM_ADD, &m_icon);

	MSG msg ;
	while (::GetMessage(&msg, NULL, 0, 0))
	{
		::TranslateMessage(&msg);
		::DispatchMessage(&msg);
	}

	::Shell_NotifyIcon(NIM_DELETE, &m_icon);
}

BOOL CALLBACK CSysTrayMenu::EnumWindowsCallback(HWND hWnd, LPARAM lParam)
{
	DWORD dwProcessID = 0;
	::GetWindowThreadProcessId(hWnd, &dwProcessID);

	if ( (dwProcessID == m_pSoleInstance->m_dwWrappedProcessID) && (::GetWindow(hWnd, GW_OWNER) == NULL) )
	{
		m_pSoleInstance->m_hWndMain = hWnd;
		return FALSE;
	}
	else
	{
		return TRUE;
	}
}

LRESULT CALLBACK CSysTrayMenu::WndProc(HWND hWnd, UINT nMsg, WPARAM wParam, LPARAM lParam)
{
    POINT pt;
	UINT nClickedItem = 0;
	HMENU& hMenu = m_pSoleInstance->m_hMenu;

	switch (lParam)
	{
	case WM_RBUTTONUP:

		if (hMenu == NULL)
		{
			hMenu = ::CreatePopupMenu();

			::AppendMenu(hMenu, MF_STRING, 3000, TEXT("Stop"));
		}

		::GetCursorPos(&pt);
		::SetForegroundWindow(hWnd); 

		nClickedItem = ::TrackPopupMenu(
							  hMenu,
							  TPM_RETURNCMD | TPM_NONOTIFY,
							  pt.x,
							  pt.y,
							  0,
							  hWnd,
							  NULL);

		switch (nClickedItem)
		{
		case 3000:
			::PostQuitMessage(0);
		}
	}

	return ::DefWindowProc(hWnd, nMsg, wParam, lParam);
}


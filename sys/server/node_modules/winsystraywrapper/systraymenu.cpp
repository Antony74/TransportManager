
#include "systraymenu.h"

#define ID_BASE_MENU 3000

CSysTrayMenu* CSysTrayMenu::m_pSoleInstance = NULL;

void CSysTrayMenu::Create(const CString& sIconPath, const CString& sTitle, HANDLE hWrappedProcess, CMenuObject& menuObject)
{
	m_pSoleInstance = new CSysTrayMenu(menuObject);
	m_pSoleInstance->m_sIconPath = sIconPath;
	m_pSoleInstance->m_sTitle = sTitle;
	m_pSoleInstance->m_hWrappedProcess = hWrappedProcess;
}

CSysTrayMenu* CSysTrayMenu::GetSoleInstance()
{
	return m_pSoleInstance;
}

DWORD WINAPI CSysTrayMenu::ThreadStart(LPVOID lpParam)
{
	_ASSERT(m_pSoleInstance);

	bool brc = m_pSoleInstance->Init();

	if (brc)
	{
		m_pSoleInstance->Run();
	}

	return 0;
}

CSysTrayMenu::CSysTrayMenu(CMenuObject& menuObject)
	: m_hMenu(NULL)
	, m_hWndMain(NULL)
	, m_dwWrappedProcessID(0)
	, m_menuObject(menuObject)
	, m_nMenuItemClicked(-1)
{
	::memset(&m_icon, 0, sizeof(NOTIFYICONDATA));

	_ASSERT(m_pSoleInstance == NULL);
	m_pSoleInstance = this;
}

CSysTrayMenu::~CSysTrayMenu()
{
	m_pSoleInstance = NULL;
}

bool CSysTrayMenu::Init()
{
	m_dwWrappedProcessID = ::GetProcessId(m_hWrappedProcess);

	HINSTANCE hInstance = ::GetModuleHandle(NULL);
	TCHAR szClassName[] = _T( "SysTrayWrapper" );

	DWORD dwTimeout = ::GetTickCount() + 5000; // Five second timeout

	while (m_hWndMain == NULL && ::GetTickCount() < dwTimeout)
	{
		::EnumWindows(EnumWindowsCallback, NULL);
		::Sleep(100);
	}

	if (m_hWndMain)
	{
		::SetWindowText(m_hWndMain, m_sTitle);

		// Get system menu of our main window
		HMENU hMenuSys = ::GetSystemMenu(m_hWndMain, 0);

		// Disable the close button
		::EnableMenuItem(hMenuSys, SC_CLOSE, MF_DISABLED);
	}

	WNDCLASSEX wnd;
	memset(&wnd, 0, sizeof(WNDCLASSEX));

	wnd.hInstance = hInstance;
	wnd.lpszClassName = szClassName;
	wnd.lpfnWndProc = WndProc;
	wnd.cbSize = sizeof (WNDCLASSEX);

	int nrc = ::RegisterClassEx(&wnd);

	if (nrc == 0)
	{
		CString sMsg;
		sMsg.Format("RegisterClassEx failed, error %d", GetLastError());
		ThrowException(Exception::Error(String::New(sMsg)));
		return false;
	}

	HWND hWnd = ::CreateWindowEx(0, szClassName, "Task bar wrapper", WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, 100, 100, NULL, NULL, hInstance, NULL);

	if (hWnd == NULL)
	{
		CString sMsg;
		sMsg.Format("CreateWindowEx failed, error %d", GetLastError());
		ThrowException(Exception::Error(String::New(sMsg)));
		return false;
	}

	m_icon.cbSize = sizeof(NOTIFYICONDATA);

	m_icon.hWnd = hWnd;
	m_icon.uID = 5000;
	m_icon.uFlags = NIF_ICON | NIF_MESSAGE | NIF_TIP;
	m_icon.uCallbackMessage = WM_USER;
	m_icon.hIcon = (HICON)LoadImage(NULL, m_sIconPath, IMAGE_ICON, 0, 0, LR_LOADFROMFILE);
	strcpy(m_icon.szTip, m_sTitle);

	return true;
}

void CSysTrayMenu::Run()
{
	::Shell_NotifyIcon(NIM_ADD, &m_icon);

	MSG msg ;
	while (::GetMessage(&msg, NULL, 0, 0))
	{
		::TranslateMessage(&msg);
		::DispatchMessage(&msg);
	}

	::Shell_NotifyIcon(NIM_DELETE, &m_icon);
}

BOOL CALLBACK CSysTrayMenu::EnumWindowsCallback(HWND hWnd, LPARAM lParam)
{
	return m_pSoleInstance->EnumWindowsCallbackImpl(hWnd, lParam);
}

BOOL CALLBACK CSysTrayMenu::EnumWindowsCallbackImpl(HWND hWnd, LPARAM lParam)
{
	DWORD dwProcessID = 0;
	::GetWindowThreadProcessId(hWnd, &dwProcessID);

	if (dwProcessID == m_dwWrappedProcessID)
	{
		m_hWndMain = hWnd;
		return FALSE;
	}
	else
	{
		return TRUE;
	}
}

LRESULT CALLBACK CSysTrayMenu::WndProc(HWND hWnd, UINT nMsg, WPARAM wParam, LPARAM lParam)
{
	return m_pSoleInstance->WndProcImpl(hWnd, nMsg, wParam, lParam);
}

LRESULT CALLBACK CSysTrayMenu::WndProcImpl(HWND hWnd, UINT nMsg, WPARAM wParam, LPARAM lParam)
{
    POINT pt;
	int nClickedItem = 0;

	switch (lParam)
	{
	case WM_RBUTTONUP:

		if (m_hMenu == NULL)
		{
			m_hMenu = ::CreatePopupMenu();

			for (int nItem = 0; nItem < 3; ++nItem)
			{
				CString sCaption;
				sCaption.Format(_T("Thing %d"), nItem);
				::AppendMenu(m_hMenu, MF_STRING, ID_BASE_MENU + nItem, sCaption);
			}
		}

		::GetCursorPos(&pt);
		::SetForegroundWindow(hWnd); 

		int nClickedItem = ::TrackPopupMenu(
							  m_hMenu,
							  TPM_RETURNCMD | TPM_NONOTIFY,
							  pt.x,
							  pt.y,
							  0,
							  hWnd,
							  NULL);

		nClickedItem -= ID_BASE_MENU;

		if (nClickedItem >= 0 && nClickedItem < 3)
		{
			m_nMenuItemClicked = nClickedItem;
		}
	}

	return ::DefWindowProc(hWnd, nMsg, wParam, lParam);
}

bool CSysTrayMenu::Poll()
{
	if (m_nMenuItemClicked >= 0 && m_nMenuItemClicked < m_menuObject.GetLength())
	{
		m_nMenuItemClicked = -1;

		bool brc = m_menuObject.DoAction(m_nMenuItemClicked);

		if (brc == false)
		{
			::PostQuitMessage(0);
			return false;
		}
	}

	return true;
}

void CSysTrayMenu::Stop()
{
	DWORD dwResult = 0;
	LRESULT lresult = ::SendMessageTimeout(m_hWndMain, WM_CLOSE, 0, 0, SMTO_ABORTIFHUNG, 5000, &dwResult);

	int nrc = ::TerminateProcess(m_hWrappedProcess, 0);

	if (nrc)
	{
		CString sMsg;
		sMsg.Format(_T("TerminateProcess failed (%d)"), ::GetLastError());

		ThrowException(Exception::Error(String::New(sMsg)));
	}
}

CMenuObject::CMenuObject(Local<Object> oMenu)
{
	m_oMenu = Persistent<Object>::New(oMenu);
}

CMenuObject::~CMenuObject()
{
}

int CMenuObject::GetLength()
{
	return m_oMenu->Get(String::NewSymbol("length"))->Int32Value();
}

CString CMenuObject::GetCaption(int nItem)
{
	Local<Value> vItem = m_oMenu->Get(Integer::New(nItem));

	if (vItem->IsObject())
	{
		Local<Value> vCaption = vItem->ToObject()->Get(String::NewSymbol("caption"));
		CString sCaption = vCaption->IsString() ? AsCString(*vCaption) : _T("");

		if (sCaption.GetLength())
		{
			return sCaption;
		}
		else
		{
			return _T("*No caption*");
		}
	}
	else
	{
		return _T("*Not an object*");
	}
}

bool CMenuObject::DoAction(int nItem)
{
	Local<Value> vItem = m_oMenu->Get(Integer::New(nItem));

	if (vItem->IsObject())
	{
		Local<Value> vFunction = vItem->ToObject()->Get(String::NewSymbol("function"));

		if (vFunction->IsFunction())
		{
			Persistent<Context> context = Context::New();
			Context::Scope context_scope(context);
			Handle<v8::Object> global = context->Global();

			Local<Function> function = Function::Cast(*vFunction);
			function->Call(global, 0, NULL);
		}
		else
		{
			CString sMsg;
			sMsg.Format(_T("Didn't find a function within menu item %d's 'function' property"), nItem);
			ThrowException(Exception::Error(String::New(sMsg)));
			return false;
		}
	}
	else
	{
		CString sMsg;
		sMsg.Format(_T("Menu item %d is not an object"), nItem);
		ThrowException(Exception::Error(String::New(sMsg)));
		return false;
	}

	return true;
}

bool CMenuObject::DoDefaultAction()
{
	for (int nItem = 0; nItem < GetLength(); ++nItem)
	{
		Local<Value> vItem = m_oMenu->Get(Integer::New(nItem));

		if (vItem->IsObject())
		{
			Local<Value> vDefault = vItem->ToObject()->Get(String::NewSymbol("default"));

			if (vDefault->IsBoolean() && vDefault->BooleanValue() == true)
			{
				return DoAction(nItem);
			}
		}
	}

	return true;
}

CString AsCString(Value* value)
{
	CString s;
	Local<String> str = value->ToString();
	value->ToString()->WriteAscii(s.GetBuffer(str->Length()));
	s.ReleaseBuffer();
	return s;
}


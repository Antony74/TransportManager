
#include "systraymenu.h"

#define ID_BASE_MENU 3000

CSysTrayMenu* CSysTrayMenu::m_pSoleInstance = NULL;

CSysTrayMenu* CSysTrayMenu::GetSoleInstance()
{
	return m_pSoleInstance;
}

CSysTrayMenu::CSysTrayMenu(CMenuObject& menuObject)
	: m_hMenu(NULL)
	, m_hWndMain(NULL)
	, m_dwWrappedProcessID(0)
	, m_menuObject(menuObject)
{
	::memset(&m_icon, 0, sizeof(NOTIFYICONDATA));

	_ASSERT(m_pSoleInstance == NULL);
	m_pSoleInstance = this;
}

CSysTrayMenu::~CSysTrayMenu()
{
	m_pSoleInstance = NULL;
}

bool CSysTrayMenu::Init(const CString& sIconPath, const CString& sTitle, DWORD dwWrappedProcessID)
{
	m_dwWrappedProcessID = dwWrappedProcessID;

	HINSTANCE hInstance = ::GetModuleHandle(NULL);
	TCHAR szClassName[] = _T( "SysTrayWrapper" );

	::EnumWindows(EnumWindowsCallback, NULL);

	if (m_hWndMain)
	{
		::SetWindowText(m_hWndMain, sTitle);

		// Get system menu of our main window
		HMENU hMenuSys = ::GetSystemMenu(m_hWndMain, 0);

		// Disable the close button
		::EnableMenuItem(hMenuSys, SC_CLOSE, MF_DISABLED);
	}

	WNDCLASSEX wnd;
	memset(&wnd, 0, sizeof(WNDCLASSEX));

	wnd.hInstance = hInstance;
	wnd.lpszClassName = szClassName;
	wnd.lpfnWndProc = WndProc;
	wnd.cbSize = sizeof (WNDCLASSEX);

	int nrc = ::RegisterClassEx(&wnd);

	if (nrc == 0)
	{
		CString sMsg;
		sMsg.Format("RegisterClassEx failed, error %d", GetLastError());
		ThrowException(Exception::Error(String::New(sMsg)));
		return false;
	}

	HWND hWnd = ::CreateWindowEx(0, szClassName, "Task bar wrapper", WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, 100, 100, NULL, NULL, hInstance, NULL);

	if (hWnd == NULL)
	{
		CString sMsg;
		sMsg.Format("CreateWindowEx failed, error %d", GetLastError());
		ThrowException(Exception::Error(String::New(sMsg)));
		return false;
	}

	m_icon.cbSize = sizeof(NOTIFYICONDATA);

	m_icon.hWnd = hWnd;
	m_icon.uID = 5000;
	m_icon.uFlags = NIF_ICON | NIF_MESSAGE | NIF_TIP;
	m_icon.uCallbackMessage = WM_USER;
	m_icon.hIcon = (HICON)LoadImage( NULL, sIconPath, IMAGE_ICON, 0, 0, LR_LOADFROMFILE  ) ;
	strcpy(m_icon.szTip, sTitle);

	return true;
}

void CSysTrayMenu::Run()
{
	::Shell_NotifyIcon(NIM_ADD, &m_icon);

	MSG msg ;
	while (::GetMessage(&msg, NULL, 0, 0))
	{
		::TranslateMessage(&msg);
		::DispatchMessage(&msg);
	}

	::Shell_NotifyIcon(NIM_DELETE, &m_icon);
}

BOOL CALLBACK CSysTrayMenu::EnumWindowsCallback(HWND hWnd, LPARAM lParam)
{
	return m_pSoleInstance->EnumWindowsCallbackImpl(hWnd, lParam);
}

BOOL CALLBACK CSysTrayMenu::EnumWindowsCallbackImpl(HWND hWnd, LPARAM lParam)
{
	DWORD dwProcessID = 0;
	::GetWindowThreadProcessId(hWnd, &dwProcessID);

	if (dwProcessID == m_dwWrappedProcessID)
	{
		m_hWndMain = hWnd;
		return FALSE;
	}
	else
	{
		return TRUE;
	}
}

LRESULT CALLBACK CSysTrayMenu::WndProc(HWND hWnd, UINT nMsg, WPARAM wParam, LPARAM lParam)
{
	return m_pSoleInstance->WndProcImpl(hWnd, nMsg, wParam, lParam);
}

LRESULT CALLBACK CSysTrayMenu::WndProcImpl(HWND hWnd, UINT nMsg, WPARAM wParam, LPARAM lParam)
{
    POINT pt;
	int nClickedItem = 0;

	switch (lParam)
	{
	case WM_RBUTTONUP:

		if (m_hMenu == NULL)
		{
			m_hMenu = ::CreatePopupMenu();

			for (int nItem = 0; nItem < m_menuObject.GetLength(); ++nItem)
			{
				::AppendMenu(m_hMenu, MF_STRING, ID_BASE_MENU + nItem, m_menuObject.GetCaption(nItem));
			}
		}

		::GetCursorPos(&pt);
		::SetForegroundWindow(hWnd); 

		int nClickedItem = ::TrackPopupMenu(
							  m_hMenu,
							  TPM_RETURNCMD | TPM_NONOTIFY,
							  pt.x,
							  pt.y,
							  0,
							  hWnd,
							  NULL);

		nClickedItem -= ID_BASE_MENU;

		if (nClickedItem >= 0 && nClickedItem < m_menuObject.GetLength())
		{
			bool brc = m_menuObject.DoAction(nClickedItem);

			if (brc == false)
			{
				::PostQuitMessage(0);
			}
		}
	}

	return ::DefWindowProc(hWnd, nMsg, wParam, lParam);
}

void CSysTrayMenu::Stop()
{
	DWORD dwResult = 0;
	LRESULT lresult = ::SendMessageTimeout(m_hWndMain, WM_CLOSE, 0, 0, SMTO_ABORTIFHUNG, 5000, &dwResult);

	// Plan B required if that doesn't work
}

CMenuObject::CMenuObject(Local<Object> oMenu)
	: m_oMenu(oMenu)
{
}

CMenuObject::~CMenuObject()
{
}

int CMenuObject::GetLength()
{
	return m_oMenu->Get(String::NewSymbol("length"))->Int32Value();
}

CString CMenuObject::GetCaption(int nItem)
{
	Local<Value> vItem = m_oMenu->Get(Integer::New(nItem));

	if (vItem->IsObject())
	{
		Local<Value> vCaption = vItem->ToObject()->Get(String::NewSymbol("caption"));
		CString sCaption = vCaption->IsString() ? AsCString(*vCaption) : _T("");

		if (sCaption.GetLength())
		{
			return sCaption;
		}
		else
		{
			return _T("*No caption*");
		}
	}
	else
	{
		return _T("*Not an object*");
	}
}

bool CMenuObject::DoAction(int nItem)
{
	Local<Value> vItem = m_oMenu->Get(Integer::New(nItem));

	if (vItem->IsObject())
	{
		Local<Value> vFunction = vItem->ToObject()->Get(String::NewSymbol("function"));

		if (vFunction->IsFunction())
		{
			Persistent<Context> context = Context::New();
			Context::Scope context_scope(context);
			Handle<v8::Object> global = context->Global();

			Local<Function> function = Function::Cast(*vFunction);
			function->Call(global, 0, NULL);
		}
		else
		{
			CString sMsg;
			sMsg.Format(_T("Didn't find a function within menu item %d's 'function' property"), nItem);
			ThrowException(Exception::Error(String::New(sMsg)));
			return false;
		}
	}
	else
	{
		CString sMsg;
		sMsg.Format(_T("Menu item %d is not an object"), nItem);
		ThrowException(Exception::Error(String::New(sMsg)));
		return false;
	}

	return true;
}

bool CMenuObject::DoDefaultAction()
{
	for (int nItem = 0; nItem < GetLength(); ++nItem)
	{
		Local<Value> vItem = m_oMenu->Get(Integer::New(nItem));

		if (vItem->IsObject())
		{
			Local<Value> vDefault = vItem->ToObject()->Get(String::NewSymbol("default"));

			if (vDefault->IsBoolean() && vDefault->BooleanValue() == true)
			{
				return DoAction(nItem);
			}
		}
	}

	return true;
}

CString AsCString(Value* value)
{
	CString s;
	Local<String> str = value->ToString();
	value->ToString()->WriteAscii(s.GetBuffer(str->Length()));
	s.ReleaseBuffer();
	return s;
}


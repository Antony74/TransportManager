#pragma once

#include "MenuObject.h"
#include "Process.h"

class CSysTrayMenu
{
public:

	static CSysTrayMenu* Create(const CString& sIconPath, const CString& sTitle, HANDLE hWrappedProcess, CMenuObject& menuObject, bool bHideHostWin);
	static CSysTrayMenu* GetSoleInstance();
	static void Destroy();

	static DWORD WINAPI ThreadStart(LPVOID lpParam);
	static CString GetTitle();
	static void ShowLog();

	HANDLE GetWrappedProcessHandle() {return GetWrappedProcess().GetProcessHandle();}
	void SetThreadHandle(HANDLE h) {m_hThread = h;}

	bool Poll(CMenuObject& menuObject);
	void Stop();

private:

	CSysTrayMenu();
	virtual ~CSysTrayMenu();

	bool Init();
	void Run();

	static BOOL CALLBACK EnumWindowsCallback(HWND hWnd, LPARAM lParam);
	static LRESULT CALLBACK WndProc(HWND hWnd, UINT nMsg, WPARAM wParam, LPARAM lParam);

	BOOL CALLBACK EnumWindowsCallbackImpl(HWND hWnd, LPARAM lParam);
	LRESULT CALLBACK WndProcImpl(HWND hWnd, UINT nMsg, WPARAM wParam, LPARAM lParam);

	CProcess& GetWrappedProcess() {return m_vecProcesses[0];}
	CProcess& GetHostProcess()    {return m_vecProcesses[1];}
	CProcess& GetParentProcess()  {return m_vecProcesses[2];}

	void ShowMainWnd(int nCmdShow);

	CString m_sIconPath;
	CString m_sTitle;

	static CSysTrayMenu* m_pSoleInstance;

	NOTIFYICONDATA m_icon;
	HMENU m_hMenu;

	class CMenuItem
	{
	public:

		CMenuItem(const CString& sCaption, bool bDefault) : m_sCaption(sCaption), m_bDefault(bDefault) {}

		CString m_sCaption;
		bool m_bDefault;
	};

	std::vector<CMenuItem> m_vecMenuItems;

	HANDLE m_hThread;
	volatile bool m_bExiting;

	// What's the maximum number of menu items you might click in any given tenth of a second?  If as I suspect the answer is one, then this is thread safe!
	volatile int m_nMenuItemClicked;

	bool m_bHideHostWin;

	std::vector<CProcess> m_vecProcesses;
};



#include "SysTraymenu.h"

#define ID_BASE_MENU 3000

CSysTrayMenu* CSysTrayMenu::m_pSoleInstance = NULL;

CSysTrayMenu* CSysTrayMenu::Create(const CString& sIconPath, const CString& sTitle, HANDLE hWrappedProcess, CMenuObject& menuObject, bool bHideHostWin)
{
	_ASSERT(m_pSoleInstance == NULL);

	m_pSoleInstance = new CSysTrayMenu();
	m_pSoleInstance->m_sIconPath = sIconPath;
	m_pSoleInstance->m_sTitle = sTitle;
	m_pSoleInstance->m_bHideHostWin = bHideHostWin;

	CProcess wrappedProcess(hWrappedProcess);
	CProcess currentProcess(::GetCurrentProcessId());
	CProcess parentProcess(currentProcess.GetParent());
	
	if (parentProcess.GetExeFile() != "cmd.exe")
	{
		// Since we haven't been run from a batch file, it's probably not the best idea to fool with the parent process
		parentProcess = CProcess();
	}

	m_pSoleInstance->m_vecProcesses.push_back(wrappedProcess);
	m_pSoleInstance->m_vecProcesses.push_back(currentProcess);
	m_pSoleInstance->m_vecProcesses.push_back(parentProcess);

	std::vector<CMenuItem>& vec = m_pSoleInstance->m_vecMenuItems;
	vec.clear();

	for (int n = 0; n < menuObject.GetLength(); ++n)
	{
		CString sCaption = menuObject.GetCaption(n);
		bool bDefault = menuObject.GetIsDefault(n);

		vec.push_back(CMenuItem(sCaption, bDefault));
	}

	return m_pSoleInstance;
}

CSysTrayMenu* CSysTrayMenu::GetSoleInstance()
{
	return m_pSoleInstance;
}

DWORD WINAPI CSysTrayMenu::ThreadStart(LPVOID lpParam)
{
	_ASSERT(m_pSoleInstance);

	bool brc = m_pSoleInstance->Init();

	if (brc)
	{
		m_pSoleInstance->Run();
	}

	return 0;
}

CSysTrayMenu::CSysTrayMenu()
	: m_hMenu(NULL)
	, m_nMenuItemClicked(-1)
	, m_hThread(NULL)
	, m_bExiting(false)
	, m_bHideHostWin(false)
{
	::memset(&m_icon, 0, sizeof(NOTIFYICONDATA));

	_ASSERT(m_pSoleInstance == NULL);
	m_pSoleInstance = this;
}

CSysTrayMenu::~CSysTrayMenu()
{
	m_pSoleInstance = NULL;
}

bool CSysTrayMenu::Init()
{
	HINSTANCE hInstance = ::GetModuleHandle(NULL);
	TCHAR szClassName[] = _T( "SysTrayWrapper" );

	DWORD dwTimeout = ::GetTickCount() + 5000; // Five second timeout

	while (GetWrappedProcess().GetMainWnd() == NULL && ::GetTickCount() < dwTimeout)
	{
		DWORD dwExitCode = 1;
		::GetExitCodeProcess(GetWrappedProcess().GetProcessHandle(), &dwExitCode);

		if (dwExitCode != STILL_ACTIVE)
		{
			break;
		}

		::EnumWindows(EnumWindowsCallback, NULL);
		::Sleep(100);
	}

	HWND hWndWrappedMain = GetWrappedProcess().GetMainWnd();

	if (hWndWrappedMain)
	{
		::SetWindowText(hWndWrappedMain, m_sTitle);

		// Get system menu of our main window
		HMENU hMenuSys = ::GetSystemMenu(hWndWrappedMain, 0);

		// Disable the close button
		::EnableMenuItem(hMenuSys, SC_CLOSE, MF_DISABLED);
	}

	if (m_bHideHostWin)
	{
		ShowMainWnd(SW_HIDE);
	}

	WNDCLASSEX wnd;
	memset(&wnd, 0, sizeof(WNDCLASSEX));

	wnd.hInstance = hInstance;
	wnd.lpszClassName = szClassName;
	wnd.lpfnWndProc = WndProc;
	wnd.cbSize = sizeof (WNDCLASSEX);

	int nrc = ::RegisterClassEx(&wnd);

	if (nrc == 0)
	{
		CString sMsg;
		sMsg.Format("RegisterClassEx failed, error %d", GetLastError());
		::ThrowException(sMsg);
		return false;
	}

	HWND hWnd = ::CreateWindowEx(0, szClassName, "Task bar wrapper", WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, 100, 100, NULL, NULL, hInstance, NULL);

	if (hWnd == NULL)
	{
		CString sMsg;
		sMsg.Format("CreateWindowEx failed, error %d", GetLastError());
		::ThrowException(sMsg);
		return false;
	}

	m_icon.cbSize = sizeof(NOTIFYICONDATA);

	m_icon.hWnd = hWnd;
	m_icon.uID = 5000;
	m_icon.uFlags = NIF_ICON | NIF_MESSAGE | NIF_TIP;
	m_icon.uCallbackMessage = WM_USER;
	m_icon.hIcon = (HICON)LoadImage(NULL, m_sIconPath, IMAGE_ICON, 0, 0, LR_LOADFROMFILE);
	strcpy(m_icon.szTip, m_sTitle);

	return true;
}

void CSysTrayMenu::Run()
{
	::Shell_NotifyIcon(NIM_ADD, &m_icon);

	MSG msg;
	while (::GetMessage(&msg, NULL, 0, 0) && !m_bExiting)
	{
		::TranslateMessage(&msg);
		::DispatchMessage(&msg);
	}

	::Shell_NotifyIcon(NIM_DELETE, &m_icon);

	if (m_bHideHostWin)
	{
		ShowMainWnd(SW_SHOW);
	}
}

BOOL CALLBACK CSysTrayMenu::EnumWindowsCallback(HWND hWnd, LPARAM lParam)
{
	return m_pSoleInstance->EnumWindowsCallbackImpl(hWnd, lParam);
}

BOOL CALLBACK CSysTrayMenu::EnumWindowsCallbackImpl(HWND hWnd, LPARAM lParam)
{
	DWORD dwProcessID = 0;
	::GetWindowThreadProcessId(hWnd, &dwProcessID);

	for (UINT n = 0; n < m_vecProcesses.size(); ++n)
	{
		CProcess& process = m_vecProcesses[n];
		if (process.GetPID() == dwProcessID)
		{
			process.SetMainWnd(hWnd);
		}
	}

	return TRUE;
}

LRESULT CALLBACK CSysTrayMenu::WndProc(HWND hWnd, UINT nMsg, WPARAM wParam, LPARAM lParam)
{
	return m_pSoleInstance->WndProcImpl(hWnd, nMsg, wParam, lParam);
}

LRESULT CALLBACK CSysTrayMenu::WndProcImpl(HWND hWnd, UINT nMsg, WPARAM wParam, LPARAM lParam)
{
    POINT pt;
	UINT nClickedItem = -1;

	switch (lParam)
	{
	case WM_RBUTTONUP:

		if (m_hMenu == NULL)
		{
			m_hMenu = ::CreatePopupMenu();

			for (UINT nItem = 0; nItem < m_vecMenuItems.size(); ++nItem)
			{
				CMenuItem& menuItem = m_vecMenuItems[nItem];

				BOOL brc = ::AppendMenu(m_hMenu, MF_STRING, ID_BASE_MENU + nItem, menuItem.m_sCaption);

				if (brc && menuItem.m_bDefault)
				{
					::SetMenuDefaultItem(m_hMenu, nItem, TRUE);
				}
			}
		}

		::GetCursorPos(&pt);
		::SetForegroundWindow(hWnd); 

		nClickedItem = ::TrackPopupMenu(
								  m_hMenu,
								  TPM_RETURNCMD | TPM_NONOTIFY,
								  pt.x,
								  pt.y,
								  0,
								  hWnd,
								  NULL);

		nClickedItem -= ID_BASE_MENU;

		if (nClickedItem >= 0 && nClickedItem < m_vecMenuItems.size())
		{
			m_nMenuItemClicked = nClickedItem;
		}

		break;

	case WM_LBUTTONDBLCLK:

		for (UINT n = 0 ; n < m_vecMenuItems.size(); ++n)
		{
			if (m_vecMenuItems[n].m_bDefault)
			{
				m_nMenuItemClicked = n;
			}
		}
	}

	return ::DefWindowProc(hWnd, nMsg, wParam, lParam);
}

bool CSysTrayMenu::Poll(CMenuObject& menuObject)
{
	// If the wrapped process's window has been minimized, hide it

	long nStyle = ::GetWindowLong(GetWrappedProcess().GetMainWnd(), GWL_STYLE);

	if (nStyle & WS_MINIMIZE)
	{
		::ShowWindow(GetWrappedProcess().GetMainWnd(), SW_HIDE);
	}

	// Deal with any menu items that have been clicked since last poll
	if (m_nMenuItemClicked >= 0 && m_nMenuItemClicked < menuObject.GetLength())
	{
		bool brc = menuObject.DoAction(m_nMenuItemClicked);

		m_nMenuItemClicked = -1;

		if (brc == false)
		{
			return false;
		}
	}

	return true;
}

void CSysTrayMenu::ShowLog()
{
	CSysTrayMenu* pSysTrayMeny = GetSoleInstance();

	if (pSysTrayMeny)
	{
		HWND hWnd = pSysTrayMeny->GetWrappedProcess().GetMainWnd();
		::ShowWindow(hWnd, SW_RESTORE);
		::SetForegroundWindow(hWnd);
	}
}

void CSysTrayMenu::Stop()
{
	//
	// Stop wrapped process
	//
	DWORD dwResult = 0;
	LRESULT lresult = ::SendMessageTimeout(GetWrappedProcess().GetMainWnd(), WM_CLOSE, 0, 0, SMTO_ABORTIFHUNG, 5000, &dwResult);

	int nrc = ::TerminateProcess(GetWrappedProcess().GetProcessHandle(), 0);

	if (nrc)
	{
		CString sMsg;
		sMsg.Format(_T("TerminateProcess failed (%d)"), ::GetLastError());

		::ThrowException(sMsg);
	}

	//
	// Stop our worker thread
	//

	m_bExiting = true;
	::PostThreadMessage(::GetThreadId(m_hThread), WM_CLOSE, 0, 0);
	::WaitForSingleObject(m_hThread, 5000);

}

void CSysTrayMenu::Destroy()
{
	delete m_pSoleInstance;
	m_pSoleInstance = NULL;
}

void CSysTrayMenu::ShowMainWnd(int nShowCmd)
{
	HWND hMainWnd = GetHostProcess().GetMainWnd() ? GetHostProcess().GetMainWnd() : GetParentProcess().GetMainWnd();
	if (hMainWnd)
	{
		::ShowWindow(hMainWnd, nShowCmd);
	}
}

CString CSysTrayMenu::GetTitle()
{
	if (m_pSoleInstance)
	{
		return m_pSoleInstance->m_sTitle;
	}
	else
	{
		return _T("Systray wrapper");
	}
}


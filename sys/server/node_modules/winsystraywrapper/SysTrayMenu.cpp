
#include "SysTraymenu.h"

#define ID_BASE_MENU 3000

CSysTrayMenu* CSysTrayMenu::m_pSoleInstance = NULL;

void CSysTrayMenu::Create(const CString& sIconPath, const CString& sTitle, HANDLE hWrappedProcess)
{
	m_pSoleInstance = new CSysTrayMenu();
	m_pSoleInstance->m_sIconPath = sIconPath;
	m_pSoleInstance->m_sTitle = sTitle;
	m_pSoleInstance->m_hWrappedProcess = hWrappedProcess;
}

CSysTrayMenu* CSysTrayMenu::GetSoleInstance()
{
	return m_pSoleInstance;
}

DWORD WINAPI CSysTrayMenu::ThreadStart(LPVOID lpParam)
{
	_ASSERT(m_pSoleInstance);

	bool brc = m_pSoleInstance->Init();

	if (brc)
	{
		m_pSoleInstance->Run();
	}

	return 0;
}

CSysTrayMenu::CSysTrayMenu()
	: m_hMenu(NULL)
	, m_hWndWrappedMain(NULL)
	, m_dwWrappedProcessID(0)
	, m_nMenuItemClicked(-1)
{
	::memset(&m_icon, 0, sizeof(NOTIFYICONDATA));

	_ASSERT(m_pSoleInstance == NULL);
	m_pSoleInstance = this;
}

CSysTrayMenu::~CSysTrayMenu()
{
	m_pSoleInstance = NULL;
}

bool CSysTrayMenu::Init()
{
	m_dwWrappedProcessID = ::GetProcessId(m_hWrappedProcess);

	HINSTANCE hInstance = ::GetModuleHandle(NULL);
	TCHAR szClassName[] = _T( "SysTrayWrapper" );

	DWORD dwTimeout = ::GetTickCount() + 5000; // Five second timeout

	while (m_hWndWrappedMain == NULL && ::GetTickCount() < dwTimeout)
	{
		::EnumWindows(EnumWindowsCallback, NULL);
		::Sleep(100);
	}

	if (m_hWndWrappedMain)
	{
		::SetWindowText(m_hWndWrappedMain, m_sTitle);

		// Get system menu of our main window
		HMENU hMenuSys = ::GetSystemMenu(m_hWndWrappedMain, 0);

		// Disable the close button
		::EnableMenuItem(hMenuSys, SC_CLOSE, MF_DISABLED);
	}

	WNDCLASSEX wnd;
	memset(&wnd, 0, sizeof(WNDCLASSEX));

	wnd.hInstance = hInstance;
	wnd.lpszClassName = szClassName;
	wnd.lpfnWndProc = WndProc;
	wnd.cbSize = sizeof (WNDCLASSEX);

	int nrc = ::RegisterClassEx(&wnd);

	if (nrc == 0)
	{
		CString sMsg;
		sMsg.Format("RegisterClassEx failed, error %d", GetLastError());
		ThrowException(Exception::Error(String::New(sMsg)));
		return false;
	}

	HWND hWnd = ::CreateWindowEx(0, szClassName, "Task bar wrapper", WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, 100, 100, NULL, NULL, hInstance, NULL);

	if (hWnd == NULL)
	{
		CString sMsg;
		sMsg.Format("CreateWindowEx failed, error %d", GetLastError());
		ThrowException(Exception::Error(String::New(sMsg)));
		return false;
	}

	m_icon.cbSize = sizeof(NOTIFYICONDATA);

	m_icon.hWnd = hWnd;
	m_icon.uID = 5000;
	m_icon.uFlags = NIF_ICON | NIF_MESSAGE | NIF_TIP;
	m_icon.uCallbackMessage = WM_USER;
	m_icon.hIcon = (HICON)LoadImage(NULL, m_sIconPath, IMAGE_ICON, 0, 0, LR_LOADFROMFILE);
	strcpy(m_icon.szTip, m_sTitle);

	return true;
}

void CSysTrayMenu::Run()
{
	::Shell_NotifyIcon(NIM_ADD, &m_icon);

	MSG msg ;
	while (::GetMessage(&msg, NULL, 0, 0))
	{
		::TranslateMessage(&msg);
		::DispatchMessage(&msg);
	}

	::Shell_NotifyIcon(NIM_DELETE, &m_icon);
}

BOOL CALLBACK CSysTrayMenu::EnumWindowsCallback(HWND hWnd, LPARAM lParam)
{
	return m_pSoleInstance->EnumWindowsCallbackImpl(hWnd, lParam);
}

BOOL CALLBACK CSysTrayMenu::EnumWindowsCallbackImpl(HWND hWnd, LPARAM lParam)
{
	DWORD dwProcessID = 0;
	::GetWindowThreadProcessId(hWnd, &dwProcessID);

	if (dwProcessID == m_dwWrappedProcessID)
	{
		m_hWndWrappedMain = hWnd;
		return FALSE;
	}
	else
	{
		return TRUE;
	}
}

LRESULT CALLBACK CSysTrayMenu::WndProc(HWND hWnd, UINT nMsg, WPARAM wParam, LPARAM lParam)
{
	return m_pSoleInstance->WndProcImpl(hWnd, nMsg, wParam, lParam);
}

LRESULT CALLBACK CSysTrayMenu::WndProcImpl(HWND hWnd, UINT nMsg, WPARAM wParam, LPARAM lParam)
{
    POINT pt;
	int nClickedItem = 0;

	switch (lParam)
	{
	case WM_RBUTTONUP:

		if (m_hMenu == NULL)
		{
			m_hMenu = ::CreatePopupMenu();

			for (int nItem = 0; nItem < 3; ++nItem)
			{
				CString sCaption;
				sCaption.Format(_T("Thing %d"), nItem);
				::AppendMenu(m_hMenu, MF_STRING, ID_BASE_MENU + nItem, sCaption);
			}
		}

		::GetCursorPos(&pt);
		::SetForegroundWindow(hWnd); 

		int nClickedItem = ::TrackPopupMenu(
							  m_hMenu,
							  TPM_RETURNCMD | TPM_NONOTIFY,
							  pt.x,
							  pt.y,
							  0,
							  hWnd,
							  NULL);

		nClickedItem -= ID_BASE_MENU;

		if (nClickedItem >= 0 && nClickedItem < 3)
		{
			m_nMenuItemClicked = nClickedItem;
		}
	}

	return ::DefWindowProc(hWnd, nMsg, wParam, lParam);
}

bool CSysTrayMenu::Poll(CMenuObject& menuObject)
{
	if (m_nMenuItemClicked >= 0 && m_nMenuItemClicked < menuObject.GetLength())
	{
		bool brc = menuObject.DoAction(m_nMenuItemClicked);

		m_nMenuItemClicked = -1;

		if (brc == false)
		{
			::PostQuitMessage(0);
			return false;
		}
	}

	return true;
}

void CSysTrayMenu::StopWrappedProcess()
{
	DWORD dwResult = 0;
	LRESULT lresult = ::SendMessageTimeout(m_hWndWrappedMain, WM_CLOSE, 0, 0, SMTO_ABORTIFHUNG, 5000, &dwResult);

	int nrc = ::TerminateProcess(m_hWrappedProcess, 0);

	if (nrc)
	{
		CString sMsg;
		sMsg.Format(_T("TerminateProcess failed (%d)"), ::GetLastError());

		ThrowException(Exception::Error(String::New(sMsg)));
	}
}

void CSysTrayMenu::Close()
{
	if (m_pSoleInstance)
	{
		DWORD dwResult = 0;
		LRESULT lresult = ::SendMessageTimeout(m_pSoleInstance->m_icon.hWnd, WM_CLOSE, 0, 0, SMTO_ABORTIFHUNG, 5000, &dwResult);

		delete m_pSoleInstance;
	}

	m_pSoleInstance = NULL;
}


#include "systraymenu.h"

Persistent<Value> g_menu;

Handle<Value> poll(const Arguments& args);

Handle<Value> run(const Arguments& args)
{
	HandleScope scope;

	if (args.Length() != 1 || args[0]->IsObject() == false)
	{
		ThrowException(Exception::Error(String::New("'run' function expected one argument, which should be an object")));
		return scope.Close(Undefined());
	}

	Local<Value> vIcon      = args[0]->ToObject()->Get(String::NewSymbol("icon"));
	Local<Value> vTitle     = args[0]->ToObject()->Get(String::NewSymbol("title"));
	Local<Value> vExe       = args[0]->ToObject()->Get(String::NewSymbol("exe"));
	Local<Value> vArguments = args[0]->ToObject()->Get(String::NewSymbol("arguments"));
	Local<Value> vMenu      = args[0]->ToObject()->Get(String::NewSymbol("menu"));

	CString sIconPath  = vIcon->IsString()      ? AsCString(*vIcon)      : _T("");
	CString sTitle     = vTitle->IsString()     ? AsCString(*vTitle)     : _T("");
	CString sExe       = vExe->IsString()       ? AsCString(*vExe)       : _T("");
	CString sArguments = vArguments->IsString() ? AsCString(*vArguments) : _T("");

	if (sIconPath == _T(""))
	{
		ThrowException(Exception::Error(String::New("'icon' property not specified")));
		return scope.Close(Undefined());
	}

	if (sTitle == _T(""))
	{
		sTitle = _T("Systray wrapper");
	}

	if (sExe == _T(""))
	{
		ThrowException(Exception::Error(String::New("'exe' property not specified")));
		return scope.Close(Undefined());
	}

	if (vMenu->IsUndefined())
	{
		ThrowException(Exception::Error(String::New("'menu' array property not specified")));
		return scope.Close(Undefined());
	}
	else if (!vMenu->IsArray())
	{
		ThrowException(Exception::Error(String::New("'menu' property is not an array")));
		return scope.Close(Undefined());
	}

	g_menu = Persistent<Value>::New(vMenu);
	CMenuObject menuObject(g_menu->ToObject());

	if (menuObject.GetLength() == 0)
	{
		ThrowException(Exception::Error(String::New("'menu' array is empty")));
		return scope.Close(Undefined());
	}

	SHELLEXECUTEINFO shellExecuteInfo;
	::memset(&shellExecuteInfo, 0, sizeof(SHELLEXECUTEINFO));
	shellExecuteInfo.cbSize = sizeof(SHELLEXECUTEINFO);
	shellExecuteInfo.fMask = SEE_MASK_NOCLOSEPROCESS;
	shellExecuteInfo.lpFile = sExe;
	shellExecuteInfo.lpParameters = sArguments;
	shellExecuteInfo.nShow = SW_SHOW;

	BOOL brc = ShellExecuteEx(&shellExecuteInfo);

	if (brc)
	{
		CSysTrayMenu* pSysTrayMenu = CSysTrayMenu::Create(sIconPath, sTitle, shellExecuteInfo.hProcess, menuObject);

		HANDLE hThread = ::CreateThread( 
            NULL,                      // default security attributes
            0,                         // use default stack size  
			CSysTrayMenu::ThreadStart, // thread function name
            NULL,					   // argument to thread function 
            0,                         // use default creation flags 
            NULL);					   // returns the thread identifier 

		if (!hThread)
		{
			CString sMsg;
			sMsg.Format(_T("CreateThread failed (%d)"), ::GetLastError());

			ThrowException(Exception::Error(String::New(sMsg)));
		}

		pSysTrayMenu->SetThreadHandle(hThread);
	}
	else
	{
		CString sMsg;
		sMsg.Format(_T("ShellExecuteEx failed (%d)"), ::GetLastError());

		ThrowException(Exception::Error(String::New(sMsg)));
	}

	//
	// Start a poll loop.  This is done in JavaScript so that Node knows
	// we are running something and does not exit before we are finished.
	//

	Context::GetCurrent()->Global()->Set(String::New("poll"), FunctionTemplate::New(poll)->GetFunction());

	Local<Script> script = Script::Compile(String::New(

			"	var interval = setInterval(function()	"
			"	{										"
			"		var brc = poll();					"
			"											"	    
			"		if (brc == false)					"
			"		{									"
			"			clearInterval(interval);		"
			"		}									"
			"											"	    
			"	}, 100);								"

		));

	script->Run();

	return scope.Close(Undefined());
}

bool waitForExit(DWORD dwTimeout)
{
	DWORD dwTimedout = ::GetTickCount() + dwTimeout;

	CSysTrayMenu* pSysTrayMenu = CSysTrayMenu::GetSoleInstance();

	if (pSysTrayMenu)
	{
		HANDLE hProcess = pSysTrayMenu->GetWrappedProcessHandle();

		do
		{
			DWORD dwExitCode = 1;
			::GetExitCodeProcess(hProcess, &dwExitCode);

			if (dwExitCode != STILL_ACTIVE)
			{
				return true; 
			}
		} while(::GetTickCount() < dwTimedout);
	}

	return false;
}

Handle<Value> poll(const Arguments& args)
{
	HandleScope scope;

	if (args.Length())
	{
		ThrowException(Exception::Error(String::New("'poll' function does not take any arguments")));
		return scope.Close(Boolean::New(false));
	}

	CSysTrayMenu* pSysTray = CSysTrayMenu::GetSoleInstance();

	if (pSysTray == NULL)
	{
		ThrowException(Exception::Error(String::New("'poll' called when winsystraywrapper is not running.  Call 'run' first.")));
		return scope.Close(Boolean::New(false));
	}

	bool bContinue = !waitForExit(0);

	if (bContinue)
	{
		CMenuObject menuObject(g_menu->ToObject());
		bContinue = pSysTray->Poll(menuObject);
	}

	return scope.Close(Boolean::New(bContinue));
}

Handle<Value> stop(const Arguments& args)
{
	HandleScope scope;

	if (args.Length())
	{
		ThrowException(Exception::Error(String::New("'stop' function does not take any arguments")));
		return scope.Close(Undefined());
	}

	CSysTrayMenu* pSysTrayMenu = CSysTrayMenu::GetSoleInstance();

	if (pSysTrayMenu)
	{
		pSysTrayMenu->Stop();
	}

	return scope.Close(Undefined());
}

Handle<Value> waitForExit(const Arguments& args)
{
	HandleScope scope;

	if (args.Length() != 1)
	{
		ThrowException(Exception::Error(String::New("'waitForExit' must specify timeout in milliseconds")));
		return scope.Close(Boolean::New(false));
	}

	DWORD dwTimeout = ::GetTickCount() + args[0]->Int32Value();

	bool brc = waitForExit(dwTimeout);
	return scope.Close(Boolean::New(brc));
}

void uninit(void*)
{
	CSysTrayMenu::Destroy();
}

void init(Handle<Object> exports)
{
	exports->Set(String::NewSymbol("run"),  FunctionTemplate::New(run)->GetFunction());
	exports->Set(String::NewSymbol("stop"),  FunctionTemplate::New(stop)->GetFunction());
	exports->Set(String::NewSymbol("waitForExit"),  FunctionTemplate::New(waitForExit)->GetFunction());
	node::AtExit(uninit);
}

NODE_MODULE(winsystraywrapper, init)


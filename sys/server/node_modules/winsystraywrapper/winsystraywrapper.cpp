#include "systraymenu.h"

CString AsCString(Value* value)
{
	CString s;
	Local<String> str = value->ToString();
	value->ToString()->WriteAscii(s.GetBuffer(str->Length()));
	s.ReleaseBuffer();
	return s;
}

Handle<Value> run(const Arguments& args)
{
	HandleScope scope;

	if (args.Length() != 1 || args[0]->IsObject() == false)
	{
		ThrowException(Exception::Error(String::New("'run' function expected one argument, which should be an object")));
		return scope.Close(Undefined());
	}

	Local<Value> vIcon      = args[0]->ToObject()->Get(String::NewSymbol("icon"));
	Local<Value> vTitle     = args[0]->ToObject()->Get(String::NewSymbol("title"));
	Local<Value> vExe       = args[0]->ToObject()->Get(String::NewSymbol("exe"));
	Local<Value> vArguments = args[0]->ToObject()->Get(String::NewSymbol("arguments"));

	CString sIconPath  = vIcon->IsString()      ? AsCString(*vIcon)      : _T("");
	CString sTitle     = vTitle->IsString()     ? AsCString(*vTitle)     : _T("");
	CString sExe       = vExe->IsString()       ? AsCString(*vExe)       : _T("");
	CString sArguments = vArguments->IsString() ? AsCString(*vArguments) : _T("");

	if (sIconPath == _T(""))
	{
		ThrowException(Exception::Error(String::New("'icon' property not specified")));
		return scope.Close(Undefined());
	}

	if (sTitle == _T(""))
	{
		sTitle = _T("Systray wrapper");
	}

	if (sExe == _T(""))
	{
		ThrowException(Exception::Error(String::New("'exe' property not specified")));
		return scope.Close(Undefined());
	}

	CSysTrayMenu sysTrayMenu;
	bool brc = sysTrayMenu.Init(sIconPath, sTitle);

	if (brc)
	{
		HINSTANCE hInstance = ::ShellExecute(NULL, "open", sExe, sArguments, NULL, SW_SHOW);

		if ((int)hInstance > 32)
		{
			sysTrayMenu.Run();
		}
		else
		{
			CString sMsg;

			switch((int)hInstance)
			{
			case ERROR_FILE_NOT_FOUND:
				sMsg = _T("ShellExecute failed - file not found");
				break;
			case ERROR_PATH_NOT_FOUND:
				sMsg = _T("ShellExecute failed - path not found");
				break;
			case ERROR_BAD_FORMAT:
				sMsg = _T("ShellExecute failed - bad format");
				break;
			case SE_ERR_ACCESSDENIED:
				sMsg = _T("ShellExecute failed - access denied");
				break;
			case SE_ERR_ASSOCINCOMPLETE:
				sMsg = _T("ShellExecute failed - file association is incomplete or invalid");
				break;
			case SE_ERR_DDEBUSY:
				sMsg = _T("ShellExecute failed - DDE busy");
				break;
			case SE_ERR_DDEFAIL:
				sMsg = _T("ShellExecute failed - DDE failed");
				break;
			case SE_ERR_DDETIMEOUT:
				sMsg = _T("ShellExecute failed - DDE time out");
				break;
			case SE_ERR_DLLNOTFOUND:
				sMsg = _T("ShellExecute failed - DLL not found");
				break;
			case SE_ERR_NOASSOC:
				sMsg = _T("ShellExecute failed - no file association");
				break;
			case SE_ERR_SHARE:
				sMsg = _T("ShellExecute failed - sharing violation");
				break;
			default:
				sMsg.Format(_T("ShellExecute failed (%d)"), hInstance);
			}

			ThrowException(Exception::Error(String::New(sMsg)));
		}
	}

	return scope.Close(Undefined());
}

void init(Handle<Object> exports)
{
	exports->Set(String::NewSymbol("run"),  FunctionTemplate::New(run)->GetFunction());
}

NODE_MODULE(winsystraywrapper, init)


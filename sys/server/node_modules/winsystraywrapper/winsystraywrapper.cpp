#pragma warning (disable: 4506) // v8 can probably be forgiven this nonsense: no definition for inline function 'v8::Persistent<T> v8::Persistent<T>::New(v8::Handle<T>)
#pragma warning (disable: 4530) // This is a node-gyp issue: C++ exception handler used, but unwind semantics are not enabled. Specify /EHsc

// A bit of MFC stuff
#define WINVER 0x0600
#include <afxdisp.h>

// A bit of JavaScript stuff
#include <node.h>
#include <v8.h>
using namespace v8;

void uninit(void* p);
Handle<Value> run(const Arguments& args);

NOTIFYICONDATA g_icon;
HMENU g_menu = NULL;
HWND g_hWndMain = NULL;

CString AsCString(Value* value)
{
	CString s;
	Local<String> str = value->ToString();
	value->ToString()->WriteAscii(s.GetBuffer(str->Length()));
	s.ReleaseBuffer();
	return s;
}

LRESULT CALLBACK WndProc(HWND hWnd, UINT nMsg, WPARAM wParam, LPARAM lParam)
{
    POINT pt;
	UINT nClickedItem = 0;

	switch (lParam)
	{
	case WM_RBUTTONUP:

		if (g_menu == NULL)
		{
			g_menu = ::CreatePopupMenu();

			::AppendMenu(g_menu, MF_STRING, 3000, TEXT("Stop"));
		}

		::GetCursorPos(&pt);
		::SetForegroundWindow(hWnd); 

		nClickedItem = ::TrackPopupMenu(
							  g_menu,
							  TPM_RETURNCMD | TPM_NONOTIFY,
							  pt.x,
							  pt.y,
							  0,
							  hWnd,
							  NULL);

		switch (nClickedItem)
		{
		case 3000:
			::PostQuitMessage(0);
		}
	}

	return ::DefWindowProc(hWnd, nMsg, wParam, lParam);
}

void init(Handle<Object> exports)
{
	exports->Set(String::NewSymbol("run"),  FunctionTemplate::New(run)->GetFunction());
	node::AtExit(uninit);
}

BOOL CALLBACK EnumWindowsCallback(HWND hWnd, LPARAM lParam)
{
	DWORD dwOtherProcessId = 0;
	::GetWindowThreadProcessId(hWnd, &dwOtherProcessId);

	if (dwOtherProcessId == ::GetCurrentProcessId() && ::GetWindow(hWnd, GW_OWNER) == NULL)
	{
		g_hWndMain = hWnd;
		return FALSE;
	}
	else
	{
		return TRUE;
	}
}

bool prepare(const CString& sIconPath, const CString& sTitle)
{
	HINSTANCE hInstance = ::GetModuleHandle(NULL);
	TCHAR szClassName[] = _T( "SysTrayWrapper" );

	::EnumWindows(EnumWindowsCallback, NULL);

	if (g_hWndMain)
	{
		::SetWindowText(g_hWndMain, sTitle);

		// Get system menu of our main window
		HMENU hMenuSys = ::GetSystemMenu(g_hWndMain, 0);

		// Disable the close button
		::EnableMenuItem(hMenuSys, SC_CLOSE, MF_DISABLED);
	}

	WNDCLASSEX wnd;
	memset(&wnd, 0, sizeof(WNDCLASSEX));

	wnd.hInstance = hInstance;
	wnd.lpszClassName = szClassName;
	wnd.lpfnWndProc = WndProc;
	wnd.cbSize = sizeof (WNDCLASSEX);

	int nrc = ::RegisterClassEx(&wnd);

	if (nrc == 0)
	{
		CString sMsg;
		sMsg.Format("RegisterClassEx failed, error %d", GetLastError());
		ThrowException(Exception::Error(String::New(sMsg)));
		return false;
	}

	HWND hWnd = ::CreateWindowEx(0, szClassName, "Task bar wrapper", WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, 100, 100, NULL, NULL, hInstance, NULL);

	if (hWnd == NULL)
	{
		CString sMsg;
		sMsg.Format("CreateWindowEx failed, error %d", GetLastError());
		ThrowException(Exception::Error(String::New(sMsg)));
		return false;
	}

	::memset(&g_icon, 0, sizeof(NOTIFYICONDATA));
	g_icon.cbSize = sizeof(NOTIFYICONDATA);

	g_icon.hWnd = hWnd;
	g_icon.uID = 5000;
	g_icon.uFlags = NIF_ICON | NIF_MESSAGE | NIF_TIP;
	g_icon.uCallbackMessage = WM_USER;
	g_icon.hIcon = (HICON)LoadImage( NULL, sIconPath, IMAGE_ICON, 0, 0, LR_LOADFROMFILE  ) ;
	strcpy(g_icon.szTip, sTitle);

	return true;
}

Handle<Value> run(const Arguments& args)
{
	HandleScope scope;

	if (args.Length() != 1 || args[0]->IsObject() == false)
	{
		ThrowException(Exception::Error(String::New("'run' function expected one argument, which should be an object")));
		return scope.Close(Undefined());
	}

	Local<Value> vIcon = args[0]->ToObject()->Get(String::NewSymbol("icon"));
	Local<Value> vTitle = args[0]->ToObject()->Get(String::NewSymbol("title"));

	CString sIconPath = vIcon->IsString() ? AsCString(*vIcon)  : _T("");
	CString sTitle = vTitle->IsString()   ? AsCString(*vTitle) : _T("");

	if (sIconPath == _T(""))
	{
		ThrowException(Exception::Error(String::New("'icon' property not specified")));
		return scope.Close(Undefined());
	}

	if (sTitle == _T(""))
	{
		sTitle = _T("Systray wrapper");
	}

	bool brc = prepare(sIconPath, sTitle);

	if (brc)
	{
		::Shell_NotifyIcon(NIM_ADD, &g_icon);

		MSG msg ;
		while (::GetMessage(&msg, NULL, 0, 0))
		{
			::TranslateMessage(&msg);
			::DispatchMessage(&msg);
		}

		::Shell_NotifyIcon(NIM_DELETE, &g_icon);
	}

	return scope.Close(Undefined());
}

void uninit(void* p)
{
}

NODE_MODULE(winsystraywrapper, init)


#include "systraymenu.h"

Handle<Value> run(const Arguments& args)
{
	HandleScope scope;

	if (args.Length() != 1 || args[0]->IsObject() == false)
	{
		ThrowException(Exception::Error(String::New("'run' function expected one argument, which should be an object")));
		return scope.Close(Undefined());
	}

	Local<Value> vIcon      = args[0]->ToObject()->Get(String::NewSymbol("icon"));
	Local<Value> vTitle     = args[0]->ToObject()->Get(String::NewSymbol("title"));
	Local<Value> vExe       = args[0]->ToObject()->Get(String::NewSymbol("exe"));
	Local<Value> vArguments = args[0]->ToObject()->Get(String::NewSymbol("arguments"));
	Local<Value> vMenu      = args[0]->ToObject()->Get(String::NewSymbol("menu"));

	CString sIconPath  = vIcon->IsString()      ? AsCString(*vIcon)      : _T("");
	CString sTitle     = vTitle->IsString()     ? AsCString(*vTitle)     : _T("");
	CString sExe       = vExe->IsString()       ? AsCString(*vExe)       : _T("");
	CString sArguments = vArguments->IsString() ? AsCString(*vArguments) : _T("");

	if (sIconPath == _T(""))
	{
		ThrowException(Exception::Error(String::New("'icon' property not specified")));
		return scope.Close(Undefined());
	}

	if (sTitle == _T(""))
	{
		sTitle = _T("Systray wrapper");
	}

	if (sExe == _T(""))
	{
		ThrowException(Exception::Error(String::New("'exe' property not specified")));
		return scope.Close(Undefined());
	}

	if (vMenu->IsUndefined())
	{
		ThrowException(Exception::Error(String::New("'menu' array property not specified")));
		return scope.Close(Undefined());
	}
	else if (!vMenu->IsArray())
	{
		ThrowException(Exception::Error(String::New("'menu' property is not an array")));
		return scope.Close(Undefined());
	}

	CMenuObject menuObject(vMenu->ToObject());

	if (menuObject.GetLength() == 0)
	{
		ThrowException(Exception::Error(String::New("'menu' array is empty")));
		return scope.Close(Undefined());
	}

	SHELLEXECUTEINFO shellExecuteInfo;
	::memset(&shellExecuteInfo, 0, sizeof(SHELLEXECUTEINFO));
	shellExecuteInfo.cbSize = sizeof(SHELLEXECUTEINFO);
	shellExecuteInfo.fMask = SEE_MASK_NOCLOSEPROCESS;
	shellExecuteInfo.lpFile = sExe;
	shellExecuteInfo.lpParameters = sArguments;
	shellExecuteInfo.nShow = SW_SHOW;

	BOOL brc = ShellExecuteEx(&shellExecuteInfo);

	if (brc)
	{
		CSysTrayMenu sysTrayMenu(menuObject);
		bool brc = sysTrayMenu.Init(sIconPath, sTitle, shellExecuteInfo.hProcess);
		
		if (brc)
		{
			sysTrayMenu.Run();
		}
	}
	else
	{
		CString sMsg;
		sMsg.Format(_T("ShellExecuteEx failed (%d)"), ::GetLastError());

		ThrowException(Exception::Error(String::New(sMsg)));
	}

	return scope.Close(Undefined());
}

Handle<Value> stop(const Arguments& args)
{
	HandleScope scope;

	if (args.Length())
	{
		ThrowException(Exception::Error(String::New("'stop' function does not take any arguments")));
		return scope.Close(Undefined());
	}

	CSysTrayMenu::GetSoleInstance()->Stop();

	::PostQuitMessage(0);

	return scope.Close(Undefined());
}

void init(Handle<Object> exports)
{
	exports->Set(String::NewSymbol("run"),  FunctionTemplate::New(run)->GetFunction());
	exports->Set(String::NewSymbol("stop"),  FunctionTemplate::New(stop)->GetFunction());
}

NODE_MODULE(winsystraywrapper, init)


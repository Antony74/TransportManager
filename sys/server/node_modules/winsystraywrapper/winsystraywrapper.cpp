#include "systraymenu.h"

#define MYSTERIOUS_ALREADY_EXITED_CODE 0xc000013a

std::map<int, CString> g_mapErrors;

Persistent<Object> g_menu;

void poll(const FunctionCallbackInfo<Value>& args);

void run(const FunctionCallbackInfo<Value>& args)
{
	HandleScope scope(Isolate::GetCurrent());

	if (args.Length() != 1 || args[0]->IsObject() == false)
	{
		::ThrowException("'run' function expected one argument, which should be an object");
		return;
	}

	Local<Value> vIcon        = args[0]->ToObject()->Get(::AsV8String("icon"));
	Local<Value> vTitle       = args[0]->ToObject()->Get(::AsV8String("title"));
	Local<Value> vExe         = args[0]->ToObject()->Get(::AsV8String("exe"));
	Local<Value> vArguments   = args[0]->ToObject()->Get(::AsV8String("arguments"));
	Local<Value> vMenu        = args[0]->ToObject()->Get(::AsV8String("menu"));
	Local<Value> vHideHostWin = args[0]->ToObject()->Get(::AsV8String("hideHostWin"));
	Local<Value> vErrorCodes  = args[0]->ToObject()->Get(::AsV8String("errorCodes"));

	CString sIconPath  = vIcon->IsString()         ? ::AsCString(vIcon)           : _T("");
	CString sTitle     = vTitle->IsString()        ? ::AsCString(vTitle)          : _T("");
	CString sExe       = vExe->IsString()          ? ::AsCString(vExe)            : _T("");
	CString sArguments = vArguments->IsString()    ? ::AsCString(vArguments)      : _T("");
	bool bHideHostWin  = vHideHostWin->IsBoolean() ? vHideHostWin->BooleanValue() : false;

	if (sIconPath == _T(""))
	{
		ThrowException("'icon' property not specified");
		return;
	}

	if (sTitle == _T(""))
	{
		sTitle = _T("Systray wrapper");
	}

	if (sExe == _T(""))
	{
		::ThrowException("'exe' property not specified");
		return;
	}

	if (vMenu->IsUndefined())
	{
		::ThrowException("'menu' array property not specified");
		return;
	}
	else if (!vMenu->IsArray())
	{
		::ThrowException("'menu' property is not an array");
		return;
	}

	g_menu.Reset(Isolate::GetCurrent(), vMenu->ToObject());
	CMenuObject menuObject(Local<Object>::New(Isolate::GetCurrent(), g_menu));

	if (menuObject.GetLength() == 0)
	{
		::ThrowException("'menu' array is empty");
		return;
	}

	if (vErrorCodes->IsObject())
	{
		Local<Object> oErrorCodes = vErrorCodes->ToObject();
		Local<Array> arrPropertyNames = oErrorCodes->GetPropertyNames();

		for (UINT n = 0; n < arrPropertyNames->Length(); ++n)
		{
			Local<Value> vErrorCode = arrPropertyNames->Get(n);
			Local<Value> vErrorMsg  = oErrorCodes->Get(vErrorCode);

			if ( !vErrorCode.IsEmpty()
			&&   !vErrorMsg.IsEmpty()
			&&   vErrorCode->IntegerValue()
			&&   vErrorMsg->IsString() )
			{
				int nErrorCode = (int)vErrorCode->IntegerValue();
				CString sError = ::AsCString(vErrorMsg);
				g_mapErrors.insert(std::make_pair(nErrorCode, sError));
			}
		}
	}

	SHELLEXECUTEINFO shellExecuteInfo;
	::memset(&shellExecuteInfo, 0, sizeof(SHELLEXECUTEINFO));
	shellExecuteInfo.cbSize = sizeof(SHELLEXECUTEINFO);
	shellExecuteInfo.fMask = SEE_MASK_NOCLOSEPROCESS;
	shellExecuteInfo.lpFile = sExe;
	shellExecuteInfo.lpParameters = sArguments;
	shellExecuteInfo.nShow = SW_SHOW;

	BOOL brc = ShellExecuteEx(&shellExecuteInfo);

	if (brc)
	{
		CSysTrayMenu* pSysTrayMenu = CSysTrayMenu::Create(sIconPath, sTitle, shellExecuteInfo.hProcess, menuObject, bHideHostWin);

		HANDLE hThread = ::CreateThread( 
            NULL,                      // default security attributes
            0,                         // use default stack size  
			CSysTrayMenu::ThreadStart, // thread function name
            NULL,					   // argument to thread function 
            0,                         // use default creation flags 
            NULL);					   // returns the thread identifier 

		if (!hThread)
		{
			CString sMsg;
			sMsg.Format(_T("CreateThread failed (%d)"), ::GetLastError());

			::ThrowException(sMsg);
		}

		pSysTrayMenu->SetThreadHandle(hThread);
	}
	else
	{
		CString sMsg;
		sMsg.Format(_T("ShellExecuteEx failed (%d)"), ::GetLastError());

		::ThrowException(sMsg);
	}

	//
	// Start a poll loop.  This is done in JavaScript so that Node knows
	// we are running something and does not exit before we are finished.
	//

	Isolate::GetCurrent()->GetCurrentContext()->Global()->Set(::AsV8String("poll"), FunctionTemplate::New(Isolate::GetCurrent(), poll)->GetFunction());

	Local<Script> script = Script::Compile(::AsV8String(

			"	var interval = setInterval(function()	"
			"	{										"
			"		var brc = poll();					"
			"											"	    
			"		if (brc == false)					"
			"		{									"
			"			clearInterval(interval);		"
			"		}									"
			"											"	    
			"	}, 100);								"

		));

	script->Run();

	return;
}

bool waitForExit(DWORD dwTimeout)
{
	DWORD dwTimedout = ::GetTickCount() + dwTimeout;

	CSysTrayMenu* pSysTrayMenu = CSysTrayMenu::GetSoleInstance();

	if (pSysTrayMenu)
	{
		HANDLE hProcess = pSysTrayMenu->GetWrappedProcessHandle();

		do
		{
			DWORD dwExitCode = 1;
			::GetExitCodeProcess(hProcess, &dwExitCode);

			if (dwExitCode != STILL_ACTIVE)
			{
				pSysTrayMenu->Stop();

				if (dwExitCode != 0 && dwExitCode != MYSTERIOUS_ALREADY_EXITED_CODE)
				{
					CString sMsg;
					CString sErrorText;

					std::map<int, CString>::iterator itr = g_mapErrors.find(dwExitCode);

					if (itr != g_mapErrors.end())
					{
						sErrorText.Format(_T(":\r\n\r\n%s"), itr->second);
					}

					sMsg.Format(_T("%s exited with an error (%d)%s"), CSysTrayMenu::GetTitle(), dwExitCode, sErrorText);
					AfxMessageBox(sMsg);
				}

				return true; 
			}

		} while(::GetTickCount() < dwTimedout);
	}

	return false;
}

void poll(const FunctionCallbackInfo<Value>& args)
{
	HandleScope scope(Isolate::GetCurrent());

	if (args.Length())
	{
		::ThrowException("'poll' function does not take any arguments");
		args.GetReturnValue().Set(Boolean::New(Isolate::GetCurrent(), false));
		return;
	}

	CSysTrayMenu* pSysTray = CSysTrayMenu::GetSoleInstance();

	if (pSysTray == NULL)
	{
		::ThrowException("'poll' called when winsystraywrapper is not running.  Call 'run' first.");
		args.GetReturnValue().Set(Boolean::New(Isolate::GetCurrent(), false));
		return;
	}

	bool bContinue = !waitForExit(0);

	if (bContinue)
	{
		CMenuObject menuObject(Local<Object>::New(Isolate::GetCurrent(), g_menu));
		bContinue = pSysTray->Poll(menuObject);
	}

	args.GetReturnValue().Set(Boolean::New(Isolate::GetCurrent(), bContinue));
}

void showLog(const FunctionCallbackInfo<Value>& args)
{
	HandleScope scope(Isolate::GetCurrent());

	if (args.Length())
	{
		::ThrowException("'showLog' function does not take any arguments");
		return;
	}

	CSysTrayMenu::ShowLog();

	return;
}

void stop(const FunctionCallbackInfo<Value>& args)
{
	HandleScope scope(Isolate::GetCurrent());

	if (args.Length())
	{
		::ThrowException("'stop' function does not take any arguments");
		return;
	}

	CSysTrayMenu* pSysTrayMenu = CSysTrayMenu::GetSoleInstance();

	if (pSysTrayMenu)
	{
		pSysTrayMenu->Stop();
	}
}

void waitForExit(const FunctionCallbackInfo<Value>& args)
{
	HandleScope scope(Isolate::GetCurrent());

	if (args.Length() != 1)
	{
		::ThrowException("'waitForExit' must specify timeout in milliseconds");
		args.GetReturnValue().Set(Boolean::New(Isolate::GetCurrent(), false));
		return;
	}

	DWORD dwTimeout = ::GetTickCount() + args[0]->Int32Value();

	bool brc = waitForExit(dwTimeout);
	args.GetReturnValue().Set(Boolean::New(Isolate::GetCurrent(), brc));
}

void uninit(void*)
{
	CSysTrayMenu::Destroy();
}

void init(Handle<Object> exports)
{
	NODE_SET_METHOD(exports, "run",         run);
	NODE_SET_METHOD(exports, "showLog",     showLog);
	NODE_SET_METHOD(exports, "stop",        stop);
	NODE_SET_METHOD(exports, "waitForExit", waitForExit);
	node::AtExit(uninit);
}

NODE_MODULE(winsystraywrapper, init)


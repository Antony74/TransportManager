#pragma warning (disable: 4506) // v8 can probably be forgiven this nonsense: no definition for inline function 'v8::Persistent<T> v8::Persistent<T>::New(v8::Handle<T>)
#pragma warning (disable: 4530) // This is a node-gyp issue: C++ exception handler used, but unwind semantics are not enabled. Specify /EHsc

// A bit of MFC stuff
#define WINVER 0x0600
#include <afxdisp.h>

// A bit of JavaScript stuff
#include <node.h>
#include <v8.h>
using namespace v8;

void uninit(void* p);
Handle<Value> run(const Arguments& args);

NOTIFYICONDATA g_icon;

CString AsCString(Value* value)
{
	CString s;
	Local<String> str = value->ToString();
	value->ToString()->WriteAscii(s.GetBuffer(str->Length()));
	s.ReleaseBuffer();
	return s;
}

LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	return ::DefWindowProc(hwnd, message, wParam, lParam);
}

void init(Handle<Object> exports)
{
	exports->Set(String::NewSymbol("run"),  FunctionTemplate::New(run)->GetFunction());
	node::AtExit(uninit);
}

bool prepare(const CString& sIconPath, const CString& sTitle)
{
	HINSTANCE hInstance = ::GetModuleHandle(NULL);
	TCHAR szClassName[] = _T( "SysTrayWrapper" );

	WNDCLASSEX wnd;
	memset(&wnd, 0, sizeof(WNDCLASSEX));

	wnd.hInstance = hInstance;
	wnd.lpszClassName = szClassName;
	wnd.lpfnWndProc = WndProc;
	wnd.cbSize = sizeof (WNDCLASSEX);

	int nrc = ::RegisterClassEx(&wnd);

	if (nrc == 0)
	{
		CString sMsg;
		sMsg.Format("RegisterClassEx failed, error %d", GetLastError());
		ThrowException(Exception::Error(String::New(sMsg)));
		return false;
	}

	HWND hWnd = ::CreateWindowEx(0, szClassName, "Task bar wrapper", WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, 100, 100, NULL, NULL, hInstance, NULL);

	if (hWnd == NULL)
	{
		CString sMsg;
		sMsg.Format("CreateWindowEx failed, error %d", GetLastError());
		ThrowException(Exception::Error(String::New(sMsg)));
		return false;
	}

	::memset(&g_icon, 0, sizeof(NOTIFYICONDATA));
	g_icon.cbSize = sizeof(NOTIFYICONDATA);

	g_icon.hWnd = hWnd;
	g_icon.uID = 5000;
	g_icon.uFlags = NIF_ICON | NIF_MESSAGE | NIF_TIP;
	g_icon.uCallbackMessage = WM_USER;
	g_icon.hIcon = (HICON)LoadImage( NULL, sIconPath, IMAGE_ICON, 0, 0, LR_LOADFROMFILE  ) ;
	strcpy(g_icon.szTip, sTitle);

	Shell_NotifyIcon(NIM_ADD, &g_icon);
	return true;
}

Handle<Value> run(const Arguments& args)
{
	HandleScope scope;

	if (args.Length() != 1 || args[0]->IsObject() == false)
	{
		ThrowException(Exception::Error(String::New("'run' function expected one argument, which should be an object")));
		return scope.Close(Undefined());
	}

	Local<Value> vIcon = args[0]->ToObject()->Get(String::NewSymbol("icon"));
	Local<Value> vTitle = args[0]->ToObject()->Get(String::NewSymbol("title"));

	CString sIconPath = vIcon->IsString() ? AsCString(*vIcon)  : _T("");
	CString sTitle = vTitle->IsString()   ? AsCString(*vTitle) : _T("");

	if (sIconPath == _T(""))
	{
		ThrowException(Exception::Error(String::New("'icon' property not specified")));
		return scope.Close(Undefined());
	}

	if (sTitle == _T(""))
	{
		sTitle = _T("Systray wrapper");
	}

	bool brc = prepare(sIconPath, sTitle);

	if (brc)
	{
		MSG msg ;
		while (GetMessage (&msg, NULL, 0, 0))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}

	return scope.Close(Undefined());
}

void uninit(void* p)
{
}

NODE_MODULE(wintaskbarwrapper, init)


#pragma warning (disable: 4506) // v8 can probably be forgiven this nonsense: no definition for inline function 'v8::Persistent<T> v8::Persistent<T>::New(v8::Handle<T>)
#pragma warning (disable: 4530) // This is a node-gyp issue: C++ exception handler used, but unwind semantics are not enabled. Specify /EHsc

#define WINVER 0x0600

#include <afxdisp.h>

#include <node.h>
#include <v8.h>
using namespace v8;

#import "C:\Program Files\Common Files\System\ado\msado15.dll" rename( "EOF", "adoEOF" )
#include <atlstr.h>

#include <vector>
#include <math.h>

CString AsCString(Handle<Value> value)
{
	CString s;
	Handle<String> str = value->ToString();
	value->ToString()->WriteAscii(s.GetBuffer(str->Length()));
	s.ReleaseBuffer();
	return s;
}

long AsLong(Handle<Value> value)
{
	return (long)value->ToInteger()->Value();
}

_variant_t AsVariant(const Handle<Value> value)
{
	if (value->IsBoolean())
	{
		return value->BooleanValue();
	}
	else if (value->IsDate())
	{
/*
		CString sScript;
		sScript.Format(
			"{                                 "
			"    year   : (new Date(%f)).getUTCFullYear(),  "
			"    month  : (new Date(%f)).getUTCMonth() + 1, "
			"    day    : (new Date(%f)).getUTCDate(),      "
			"    hour   : (new Date(%f)).getUTCHours(),     "
			"    minute : (new Date(%f)).getUTCMinutes(),   "
			"    second : (new Date(%f)).getUTCSeconds()    "
			"}",
			value->NumberValue(),
			value->NumberValue(),
			value->NumberValue(),
			value->NumberValue(),
			value->NumberValue(),
			value->NumberValue());

		Local<Script> script = Script::Compile(String::New(sScript));
		Handle<Value> value = script->Run();
		Handle<Object> date = value->ToObject();

		COleDateTime odt(date->Get(String::New("year"))->Int32Value(),
						 date->Get(String::New("month"))->Int32Value(),
						 date->Get(String::New("day"))->Int32Value(),
						 date->Get(String::New("hour"))->Int32Value(),
						 date->Get(String::New("minute"))->Int32Value(),
						 date->Get(String::New("second"))->Int32Value());
						 */
		return (DATE)0;
	}
	else if (value->IsInt32())
	{
		return _variant_t((long)value->Int32Value(), VT_I4);
	}
	else if (value->IsNumber())
	{
		return value->NumberValue();
	}
	else if (value->IsString())
	{
		return (LPCSTR)::AsCString(value->ToString());
	}
	else
	{
		_ASSERT(value->IsNull());
		return NULL;
	}
}

Handle<Value> AsV8Value(const _variant_t vtValue)
{
	switch(vtValue.vt)
	{
	case VT_NULL:
		return Null();

	case VT_BSTR:
		return String::New((CString)vtValue.bstrVal);

	case VT_I2:
	case VT_I4:
		return Integer::New(vtValue.intVal);

	case VT_R8:
		return Number::New(vtValue.dblVal);

	case VT_BOOL:
		return Boolean::New(vtValue.boolVal ? true : false);

	case VT_DATE:
		{
			// This should be a safe way of doing a date conversion, but almost certainly not a terribly quick way
			COleDateTime odt = vtValue.date;
			CString sJsDate;
			sJsDate.Format("new Date(Date.UTC(%d,%d,%d,%d,%d,%d))", odt.GetYear(), odt.GetMonth() - 1, odt.GetDay(), odt.GetHour(), odt.GetMinute(), odt.GetSecond());
			Local<Script> script = Script::Compile(String::New(sJsDate));
			Handle<Value> v = script->Run();
//			double d = v->NumberValue();
			return v;
		}

	default:
		{
			CString sMsg;
			sMsg.Format("*Type error %d*", vtValue.vt);

			if (vtValue.vt != VT_DECIMAL) // Warn if any unsupported types are used, except this one which I believe I can get away with ignoring
			{
				_ASSERT(false);
			}

			return String::New(sMsg);
		}
	}
}

CString DescribeVariant(const _variant_t vtValue)
{
	CString sValue = ::AsCString(::AsV8Value(vtValue));
	CString sType = "Unknown";
	CString sDescription;

	switch(vtValue.vt)
	{
	case VT_NULL:
		sType = "VT_NULL";
		break;

	case VT_BSTR:
		sType = "VT_BSTR";
		break;

	case VT_I2:
		sType = "VT_I2";
		break;

	case VT_I4:
		sType = "VT_I4";
		break;

	case VT_R8:
		sType = "VT_R8";
		break;

	case VT_BOOL:
		sType = "VT_BOOL";
		break;

	case VT_DATE:
		sType = "VT_DATE";
		break;
	}

	sDescription.Format("'%s'(%s)", sValue, sType);
	return sDescription;
}

//
// PopulateFromRecordset
//
void PopulateFromRecordset(long nSchemaLevel, long nStartRecord, long nNumberOfRecordsToGet, bool bSpecialSchemaRecordset, ADODB::_RecordsetPtr rs, Handle<Object> oRoot)
{
	bool bMore = false;

	Handle<Array> arrRecords = Array::New();
	Handle<Array> arrFields  = Array::New();

	if (nSchemaLevel)
	{
		int nTotalSize = 0;

		class CFieldInfo
		{
		public:
			CFieldInfo(const CString& sName, int nSize)
				: m_sName(sName), m_nSize(nSize), m_nDefinedSize(0)
			{}

			CString m_sName;
			int m_nSize;
			CString m_sType;
			long m_nDefinedSize;
		};

		std::vector<CFieldInfo> vecFieldInfo;

		for (long nField = 0; nField < rs->Fields->Count; ++nField)
		{
			ADODB::FieldPtr adoField = rs->Fields->Item[nField];

			CString sFieldname = (LPCTSTR)adoField->Name;
			int nSize = adoField->DefinedSize;

			if (nSize < 5)
			{
				nSize = 5;
			}
			else if (nSize > 25)
			{
				nSize = 25;
			}

			nTotalSize += nSize;
			vecFieldInfo.push_back(CFieldInfo(sFieldname, nSize));

			if (nSchemaLevel >= 2)
			{
				CFieldInfo& info = vecFieldInfo.back();

				long nType = adoField->Type;
				switch(nType)
				{
				case ADODB::adInteger:
					info.m_sType = "INTEGER";
					break;

				case ADODB::adBoolean:
					info.m_sType = "YESNO";
					break;

				case ADODB::adVarWChar:
					info.m_sType = _T("TEXT");
					break;

				case ADODB::adLongVarWChar:
					info.m_sType = "MEMO";
					break;

				case ADODB::adDate:
					info.m_sType = "DATE";
					break;

				default:
					info.m_sType.Format(_T("%d"), nType);
				}

				info.m_nDefinedSize = adoField->DefinedSize;
			}
		}

		for (UINT nField = 0; nField < vecFieldInfo.size(); ++nField)
		{
			CFieldInfo& info = vecFieldInfo[nField];
			int nSize = (int)::ceil(info.m_nSize * 100.0 / nTotalSize);
			CString sSize;
			sSize.Format("%d%%", nSize);

			Handle<Object> oField = Object::New();
			oField->Set(String::New("name"), String::New(info.m_sName));
			oField->Set(String::New("width"), String::New(sSize));

			if (nSchemaLevel >= 2)
			{
				oField->Set(String::New("Type"), String::New(info.m_sType));
				oField->Set(String::New("DefinedSize"), Integer::New(info.m_nDefinedSize));
			}

			arrFields->Set(arrFields->Length(), oField);
		}
	}

	int nRecordCount = rs->RecordCount;

	if ( nRecordCount == -1 && bSpecialSchemaRecordset == false )
	{
		oRoot->Set(String::New("Error"), String::New("Problem getting record count"));
	}
	else if ( ( (nStartRecord < nRecordCount) && (nStartRecord >= 0) ) || bSpecialSchemaRecordset )
	{
		if (nStartRecord == 0)
		{
			rs->MoveFirst();
		}
		else
		{
			rs->Move(nStartRecord, (long)ADODB::adBookmarkFirst);
		}

		while ( (rs->adoEOF == VARIANT_FALSE) && (nNumberOfRecordsToGet > 0) )
		{
			Handle<Object> oRecord = Object::New();

			for (long nField = 0; nField < rs->Fields->Count; ++nField)
			{
				ADODB::FieldPtr adoField = rs->Fields->Item[nField];
				CString sName = (LPCTSTR)adoField->Name;
				Handle<Value> value = ::AsV8Value(adoField->Value);
				oRecord->Set(String::New(sName), value);
			}

			arrRecords->Set(arrRecords->Length(), oRecord);

			--nNumberOfRecordsToGet;
			rs->MoveNext();
		}

		if (rs->adoEOF == VARIANT_FALSE)
		{
			bMore = true;
		}
	}

	oRoot->Set(String::New("more"), Boolean::New(bMore));

	if (nSchemaLevel)
	{
		oRoot->Set(String::New("fields"), arrFields);
	}

	oRoot->Set(String::New("records"), arrRecords);
}

//
// selectSql
//
Handle<Value> selectSql(const Arguments& args)
{
	HandleScope scope;

	if (args.Length() != 1 || args[0]->IsObject() == false)
	{
		ThrowException(Exception::Error(String::New("'selectSql' function expected one argument, which should be an object")));
		return scope.Close(Undefined());
	}

	Handle<Value> vDatabaseFilename     = args[0]->ToObject()->Get(String::NewSymbol("databaseFilename"));
	Handle<Value> vQuery                = args[0]->ToObject()->Get(String::NewSymbol("query"));
	Handle<Value> vStartRecord          = args[0]->ToObject()->Get(String::NewSymbol("startRecord"));
	Handle<Value> vNumberOfRecordsToGet = args[0]->ToObject()->Get(String::NewSymbol("numberOfRecordsToGet"));
	Handle<Value> vSchemaLevel          = args[0]->ToObject()->Get(String::NewSymbol("schemaLevel"));

	CString sDatabaseFilename  = vDatabaseFilename->IsString()     ? ::AsCString(vDatabaseFilename)  : _T("");
	CString sQuery             = vQuery->IsString()                ? ::AsCString(vQuery)		     : _T("");
	long nStartRecord		   = vStartRecord->IsNumber()          ? ::AsLong(vStartRecord)          : 0;
	long nNumberOfRecordsToGet = vNumberOfRecordsToGet->IsNumber() ? ::AsLong(vNumberOfRecordsToGet) : 20;
	long nSchemaLevel          = vSchemaLevel->IsNumber()          ? ::AsLong(vSchemaLevel)          : 0;

	if (sDatabaseFilename == _T(""))
	{
		ThrowException(Exception::Error(String::New("'selectSql' function expected 'databaseFilename' to be a non-empty string")));
		return scope.Close(Undefined());
	}

	if (sQuery == _T(""))
	{
		ThrowException(Exception::Error(String::New("'selectSql' function expected 'query' to be a non-empty string")));
		return scope.Close(Undefined());
	}

	Handle<Object> oRoot = Object::New();
	oRoot->Set(String::New("query"), String::New(sQuery));
	oRoot->Set(String::New("startRecord"), Integer::New(nStartRecord));

	try
	{
		ADODB::_ConnectionPtr db("ADODB.Connection");
		db->Provider = "Microsoft.Jet.OLEDB.4.0";
		db->Open((LPCTSTR)sDatabaseFilename, "", "", 0);

		ADODB::_RecordsetPtr rs("ADODB.Recordset");
		rs->Open((LPCSTR)sQuery, (IDispatch *)db, ADODB::adOpenStatic, ADODB::adLockUnspecified, 0);

		PopulateFromRecordset(nSchemaLevel, nStartRecord, nNumberOfRecordsToGet, false, rs, oRoot);

		rs->Close();
		db->Close();
	}
	catch(_com_error &e)
	{
		oRoot->Set(String::New("Error"), String::New(e.Description()));
	}
	catch(...)
	{
		oRoot->Set(String::New("Error"), String::New("Unidentified exception"));
	}

	return scope.Close(oRoot);
}

//
// updateDatabase
//
Handle<Value> updateDatabase(const Arguments& args)
{
	HandleScope scope;

	if (args.Length() != 2 || args[0]->IsString() == false || args[1]->IsArray() == false)
	{
		ThrowException(Exception::Error(String::New("'updateDatabase' function expected two arguments, a database filename string and an array of the update details")));
		return scope.Close(Undefined());
	}

	CString sDatabaseFilename = ::AsCString(args[0]->ToString());
	Handle<Array> arrSql(Array::Cast(*args[1]->ToObject()));

	Handle<Object> oReturnValue = Object::New();

	ADODB::_ConnectionPtr db;

	try
	{
		db = ADODB::_ConnectionPtr("ADODB.Connection");
		db->Provider = "Microsoft.Jet.OLEDB.4.0";
		db->Open((LPCTSTR)sDatabaseFilename, "", "", 0);

		db->BeginTrans();
	}
	catch(_com_error &e)
	{
		oReturnValue->Set(String::New("Error"), String::New(e.Description()));
		return scope.Close(oReturnValue);
	}
	catch(...)
	{
		oReturnValue->Set(String::New("Error"), String::New("Unidentified exception"));
		return scope.Close(oReturnValue);
	}

	bool bOK = true; // OK so far ;-)

	for (UINT nSql = 0; nSql < arrSql->Length(); ++nSql)
	{
		Handle<Value> vSql = arrSql->Get(nSql);

		if (!vSql->IsObject())
		{
			CString sError;
			sError.Format(_T("'updateDatabase' function, item %d is not an object"), nSql);
			ThrowException(Exception::Error(String::New(sError)));
			return scope.Close(Undefined());
		}

		Handle<Object> oSql = vSql->ToObject();
		Handle<Value> vTable = oSql->Get(String::New("table"));
		Handle<Value> vOperations = oSql->Get(String::New("operations"));

		if (!vTable->IsString())
		{
			CString sError;
			sError.Format(_T("'updateDatabase' function, item %d 'table' is not a string"), nSql);
			ThrowException(Exception::Error(String::New(sError)));
			bOK = false;
		}
		else if (!vOperations->IsArray())
		{
			CString sError;
			sError.Format(_T("'updateDatabase' function, item %d 'operations' is not an array"), nSql);
			ThrowException(Exception::Error(String::New(sError)));
			bOK = false;
		}
		else
		{
			CString sTable = ::AsCString(vTable->ToString());
			Handle<Array> arrOperations(Array::Cast(*vOperations));

			try
			{
				ADODB::_RecordsetPtr rs("ADODB.Recordset");
				rs->Open((LPCSTR)sTable, (IDispatch *)db, ADODB::adOpenStatic, ADODB::adLockOptimistic, ADODB::adCmdTableDirect);

				for (UINT nOperation = 0; nOperation < arrOperations->Length(); ++nOperation)
				{
					Handle<Value> vOperation = arrOperations->Get(nOperation);

					if (!vOperation->IsObject())
					{
						CString sError;
						sError.Format(_T("'updateDatabase' function, item %d, operation %d is not an object"), nSql, nOperation);
						ThrowException(Exception::Error(String::New(sError)));
						bOK = false;
						break;
					}

					Handle<Object> oOperation = vOperation->ToObject();
					Handle<Value> vOperationName = oOperation->Get(String::New("operationName"));
					Handle<Value> vOldRecord = oOperation->Get(String::New("oldRecord"));
					Handle<Value> vNewRecord = oOperation->Get(String::New("newRecord"));

					if (!vOperationName->IsString())
					{
						CString sError;
						sError.Format(_T("'updateDatabase' function, item %d, operation %d, operationName is not a string"),
									  nSql,
									  nOperation);

						ThrowException(Exception::Error(String::New(sError)));
						bOK = false;
						break;
					}

					CString sOperationName = ::AsCString(vOperationName->ToString());

					if (sOperationName == "add")
					{
						if (!vNewRecord->IsObject())
						{
							CString sError;
							sError.Format(_T("'updateDatabase' function, item %d, operation %d (add), field 'newRecord' not found"), nSql, nOperation);
							ThrowException(Exception::Error(String::New(sError)));
							bOK = false;
							break;
						}

						rs->AddNew();

						Handle<Object> oNewRecord = vNewRecord->ToObject();
						Handle<Array> arrNewRecord = oNewRecord->GetPropertyNames();

						for (UINT nFld = 0; nFld < arrNewRecord->Length(); ++nFld)
						{
							Handle<Value> vProperty = arrNewRecord->Get(nFld);
							_variant_t vtProperty = ::AsVariant(vProperty);

							_variant_t vtNewValue = ::AsVariant(oNewRecord->Get(vProperty));
							rs->Fields->GetItem(vtProperty)->PutValue(vtNewValue);
						}

						rs->Update();

					}
					else if (sOperationName == "edit")
					{
						if (!vOldRecord->IsObject())
						{
							CString sError;
							sError.Format(_T("'updateDatabase' function, item %d, operation %d, field 'oldRecord' not found"), nSql, nOperation);
							ThrowException(Exception::Error(String::New(sError)));
							bOK = false;
							break;
						}

						if (!vNewRecord->IsObject())
						{
							CString sError;
							sError.Format(_T("'updateDatabase' function, item %d, operation %d (edit), field 'newRecord' not found"), nSql, nOperation);
							ThrowException(Exception::Error(String::New(sError)));
							bOK = false;
							break;
						}

						Handle<Object> oOldRecord = vOldRecord->ToObject();
						Handle<Object> oNewRecord = vNewRecord->ToObject();

						// Let's go looking for the auto-increment field.  I'd rather be looking for the primary key,
						// but let's face it - I'd rather not be using COM, ADO and JET in the first place!

						CString sAutoIncrementFieldName;

						for (long nFld = 0; nFld < rs->Fields->GetCount(); ++nFld)
						{
							ADODB::FieldPtr fld = rs->Fields->GetItem(nFld);
							_variant_t vt = fld->GetProperties()->GetItem("ISAUTOINCREMENT")->GetValue();
							if (vt.vt == VT_BOOL && vt.boolVal == VARIANT_TRUE)
							{
								sAutoIncrementFieldName = (LPCSTR)fld->GetName();
							}
						}

						if (sAutoIncrementFieldName == "")
						{
							CString sError;
							sError.Format(_T("Auto increment field not found in table '%s'"), sTable);
							oReturnValue->Set(String::New("Error"), String::New(sError));
							bOK = false;
							break;
						}

						Handle<Value> vField = oOldRecord->Get(String::New(sAutoIncrementFieldName));
						int nAutoIncrementValue = vField->Int32Value();

						_variant_t arrKeyValues[1];
						arrKeyValues[0] = nAutoIncrementValue;

						rs->PutIndex("PrimaryKey");
						rs->Seek(arrKeyValues, ADODB::adSeekFirstEQ);

						if (rs->adoEOF)
						{
							CString sError;
							sError.Format(_T("'updateDatabase' function, item %d, operation %d database record (%s=%d) not found"), nSql, nOperation, sAutoIncrementFieldName, nAutoIncrementValue);
							oReturnValue->Set(String::New("Error"), String::New(sError));
							bOK = false;
							break;
						}

						for (long nFld = 0; nFld < rs->Fields->GetCount(); ++nFld)
						{
							ADODB::FieldPtr fld = rs->Fields->GetItem(nFld);
							CString sFieldName = (LPCSTR)fld->GetName();
							_variant_t vtExpectedValue = fld->GetValue();
							_variant_t vtOldValue = ::AsVariant(oOldRecord->Get(String::New(sFieldName)));
							_variant_t vtNewValue = ::AsVariant(oNewRecord->Get(String::New(sFieldName)));

							if (vtOldValue != vtExpectedValue)
							{
								// This issue is actually expected to occur in userland from time to time.
								// (nearly every other error indicates a software problem)

								CString sError;
								sError.Format(_T("Can't perform update because record has already changed.  Field '%s', actual value %s, expected %s, can't change to %s"),
											  sFieldName,
											  DescribeVariant(vtExpectedValue),
											  DescribeVariant(vtOldValue),
											  DescribeVariant(vtNewValue));

								oReturnValue->Set(String::New("Error"), String::New(sError));
								bOK = false;
								break;
							}

							if (vtOldValue != vtNewValue && sFieldName != sAutoIncrementFieldName)
							{
								fld->PutValue(vtNewValue);
							}
						}

						if (bOK)
						{
							rs->Update();
						}
						else
						{
							rs->CancelUpdate();
						}

					}
					else
					{
						CString sError;
						sError.Format(_T("'updateDatabase' function, item %d, operation %d, operationName '%s' not recognised"), nSql, nOperation, sOperationName);
						ThrowException(Exception::Error(String::New(sError)));
						bOK = false;
						break;
					}
				}

				rs->Close();
			}
			catch(_com_error &e)
			{
				if (bOK)
				{
					oReturnValue->Set(String::New("Error"), String::New(e.Description()));
					bOK = false;
				}
			}
			catch(...)
			{
				if (bOK)
				{
					oReturnValue->Set(String::New("Error"), String::New("Unidentified exception"));
					bOK = false;
				}
			}
		}

		if (bOK == false)
		{
			break;
		}
	}

	try
	{
		if (bOK)
		{
			db->CommitTrans();
		}
		else
		{
			db->RollbackTrans();
		}

		db->Close();
	}
	catch(_com_error &e)
	{
		oReturnValue->Set(String::New("Error"), String::New(e.Description()));
	}
	catch(...)
	{
		oReturnValue->Set(String::New("Error"), String::New("Unidentified exception"));
	}

	return scope.Close(oReturnValue);
}

//
// getIndices
//
Handle<Value> getIndices(const Arguments& args)
{
	HandleScope scope;

	if (args.Length() != 1 || args[0]->IsString() == false)
	{
		ThrowException(Exception::Error(String::New("'getIndices' function expected one argument, which should be a database filename string")));
		return scope.Close(Undefined());
	}

	CString sDatabaseFilename = ::AsCString(args[0]->ToString());

	Handle<Object> oRoot = Object::New();

	try
	{
		ADODB::_ConnectionPtr db("ADODB.Connection");
		db->Provider = "Microsoft.Jet.OLEDB.4.0";
		db->Open((LPCTSTR)sDatabaseFilename, "", "", 0);

		ADODB::_RecordsetPtr rs = db->OpenSchema(ADODB::adSchemaIndexes);

		PopulateFromRecordset(0, 0, 1000, true, rs, oRoot);

		rs->Close();
		db->Close();
	}
	catch(_com_error &e)
	{
		oRoot->Set(String::New("Error"), String::New(e.Description()));
	}
	catch(...)
	{
		oRoot->Set(String::New("Error"), String::New("Unidentified exception"));
	}

	return scope.Close(oRoot);
}

//
// runSql
//
Handle<Value> runSql(const Arguments& args)
{
	HandleScope scope;

	if (args.Length() != 2 || args[0]->IsString() == false || args[1]->IsArray() == false)
	{
		ThrowException(Exception::Error(String::New("'runSql' function expected two arguments, a database filename string, and an array of SQL statement strings")));
		return scope.Close(Undefined());
	}

	CString sDatabaseFilename = ::AsCString(args[0]->ToString());
	Handle<Array> arrSql(Array::Cast(*args[1]->ToObject()));

	try
	{
		ADODB::_ConnectionPtr db("ADODB.Connection");
		db->Provider = "Microsoft.Jet.OLEDB.4.0";
		db->Open((LPCTSTR)sDatabaseFilename, "", "", 0);

		for (UINT n = 0; n < arrSql->Length(); ++n)
		{
			Handle<Value> v = arrSql->Get(n);
			if (v->IsString())
			{
				CString sSql = ::AsCString(v);
                db->Execute(_bstr_t(sSql), NULL, 0);
			}
			else
			{
				CString sMsg;
				sMsg.Format(_T("'runSql' function found item at array index %d which was is not a string"), n);
				break;
			}
		}

		db->Close();
	}
	catch(_com_error &e)
	{
		CString sMsg;
		sMsg.Format(_T("'runSql' function encountered an error: %s"), CString(e.Description().GetBSTR()));
		ThrowException(Exception::Error(String::New(sMsg)));
	}
	catch(...)
	{
		ThrowException(Exception::Error(String::New("'runSql' function encountered an unidentified exception")));
	}

	return scope.Close(Undefined());
}

//
// init
//
void init(Handle<Object> exports)
{
	::CoInitialize(NULL);
	exports->Set(String::NewSymbol("selectSql"), FunctionTemplate::New(selectSql)->GetFunction());
	exports->Set(String::NewSymbol("updateDatabase"), FunctionTemplate::New(updateDatabase)->GetFunction());
	exports->Set(String::NewSymbol("getIndices"), FunctionTemplate::New(getIndices)->GetFunction());
	exports->Set(String::NewSymbol("runSql"), FunctionTemplate::New(runSql)->GetFunction());
}

NODE_MODULE(dface, init)

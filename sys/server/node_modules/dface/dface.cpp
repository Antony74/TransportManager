#pragma warning (disable: 4506) // v8 can probably be forgiven this nonsense: no definition for inline function 'v8::Persistent<T> v8::Persistent<T>::New(v8::Handle<T>)
#pragma warning (disable: 4530) // This is a node-gyp issue: C++ exception handler used, but unwind semantics are not enabled. Specify /EHsc

#define WINVER 0x0600

#include <afxdisp.h>

#include <node.h>
#include <v8.h>
using namespace v8;

#import "C:\Program Files\Common Files\System\ado\msado15.dll" rename( "EOF", "adoEOF" )
#include <atlstr.h>

#include <vector>
#include <math.h>

CString AsCString(Local<Value> value)
{
	CString s;
	Local<String> str = value->ToString();
	value->ToString()->WriteAscii(s.GetBuffer(str->Length()));
	s.ReleaseBuffer();
	return s;
}

Handle<Value> selectSql(const Arguments& args)
{
	CString sFilename = AsCString(args[0]);
	CString sQuery = AsCString(args[1]);
	long nStart = (long)args[2]->ToInteger()->Value();
	long nNumberOfRecordsToGet = (long)args[3]->ToInteger()->Value();

	Handle<Object> oRoot = Object::New();
	oRoot->Set(String::New("query"), String::New(sQuery));
	oRoot->Set(String::New("start"), Integer::New(nStart));
	bool bMore = false;
	
	Handle<Array> arrRecords = Array::New();
	Handle<Object> oFields = Object::New();

	try
	{
		ADODB::_ConnectionPtr db("ADODB.Connection");
		db->Provider = "Microsoft.Jet.OLEDB.4.0";
		db->Open((LPCTSTR)sFilename, "", "", 0);

		ADODB::_RecordsetPtr rs("ADODB.Recordset");
		rs->Open((LPCSTR)sQuery, (IDispatch *)db, ADODB::adOpenStatic, ADODB::adLockUnspecified, 0);

		int nTotalSize = 0;

		class CFieldInfo
		{
		public:
			CFieldInfo(const CString& sName, int nSize)
				: m_sName(sName), m_nSize(nSize)
			{}

			CString m_sName;
			int m_nSize;
		};

		std::vector<CFieldInfo> vecFieldInfo;

		oRoot->Set(String::New("FieldCount"), Integer::New(rs->Fields->Count));

		for (long nField = 0; nField < rs->Fields->Count; ++nField)
		{
			ADODB::FieldPtr adoField = rs->Fields->Item[nField];

			CString sFieldname = (LPCTSTR)adoField->Name;
			int nSize = adoField->DefinedSize;

			if (nSize < 5)
			{
				nSize = 5;
			}
			else if (nSize > 25)
			{
				nSize = 25;
			}

			nTotalSize += nSize;
			vecFieldInfo.push_back(CFieldInfo(sFieldname, nSize));
		}

		for (UINT nField = 0; nField < vecFieldInfo.size(); ++nField)
		{
			CFieldInfo& info = vecFieldInfo[nField];
			int nSize = (int)::ceil(info.m_nSize * 100.0 / nTotalSize);
			CString sSize;
			sSize.Format("%d%%", nSize);
			oFields->Set(String::New(info.m_sName), String::New(sSize));
		}

		int nRecordCount = rs->RecordCount;

		if (nRecordCount == -1)
		{
			oRoot->Set(String::New("error"), String::New("Problem getting record count"));
		}
		else if ( (nStart < nRecordCount) && (nStart >= 0) )
		{
			rs->Move(nStart, (long)ADODB::adBookmarkFirst);

			while ( (rs->adoEOF == VARIANT_FALSE) && (nNumberOfRecordsToGet > 1) )
			{
				Handle<Object> oRecord = Object::New();

				for (long nField = 0; nField < rs->Fields->Count; ++nField)
				{
					ADODB::FieldPtr adoField = rs->Fields->Item[nField];
					CString sName = (LPCTSTR)adoField->Name;
					_variant_t vtValue = adoField->Value;

					switch(vtValue.vt)
					{
					case VT_NULL:
						oRecord->Set(String::New(sName), String::New(""));

					case VT_BSTR:
						oRecord->Set(String::New(sName), String::New((CString)vtValue.bstrVal));
						break;

					case VT_I4:
						oRecord->Set(String::New(sName), Integer::New(vtValue.intVal));
						break;

					case VT_BOOL:
						oRecord->Set(String::New(sName), Boolean::New(vtValue.boolVal ? true : false));
						break;

					default:
						{
							CString sMsg;
							sMsg.Format("*Type error %d*", vtValue.vt);
							oRecord->Set(String::New(sName), String::New(sMsg));
						}
					}

				}

				arrRecords->Set(arrRecords->Length(), oRecord);

				--nNumberOfRecordsToGet;
				rs->MoveNext();
			}

			if (rs->adoEOF == VARIANT_FALSE)
			{
				bMore = true;
			}
		}

		rs->Close();
		db->Close();
	}
	catch(_com_error &e)
	{
		oRoot->Set(String::New("error"), String::New(e.Description()));
	}
	catch(...)
	{
		oRoot->Set(String::New("error"), String::New("Unidentified exception"));
	}

	oRoot->Set(String::New("more"), Boolean::New(bMore));
	oRoot->Set(String::New("fields"), oFields);
	oRoot->Set(String::New("records"), arrRecords);

	return oRoot;
}

void init(Handle<Object> exports)
{
	::CoInitialize(NULL);
	exports->Set(String::NewSymbol("selectSql"), FunctionTemplate::New(selectSql)->GetFunction());
}

NODE_MODULE(dface, init)

#pragma warning (disable: 4506) // v8 can probably be forgiven this nonsense: no definition for inline function 'v8::Persistent<T> v8::Persistent<T>::New(v8::Handle<T>)
#pragma warning (disable: 4530) // This is a node-gyp issue: C++ exception handler used, but unwind semantics are not enabled. Specify /EHsc

#define WINVER 0x0600

#include <afxdisp.h>

#include <node.h>
#include <v8.h>
using namespace v8;

#import "C:\Program Files\Common Files\System\ado\msado15.dll" rename( "EOF", "adoEOF" )
#include "oledberr.h"
#include <atlstr.h>

#include <vector>
#include <math.h>

CString AsCString(Handle<Value> value)
{
	Handle<String> str = value->ToString();
	LPWSTR lpwsz = new WCHAR[str->Length() + 1];
	value->ToString()->Write((uint16_t*)lpwsz);
	CString s(lpwsz);
	delete lpwsz;
	return s;
}

Handle<String> AsV8String(const CString& s)
{
	return String::NewFromOneByte(Isolate::GetCurrent(), (const uint8_t*)(LPCSTR)s);
}

long AsLong(Handle<Value> value)
{
	return (long)value->ToInteger()->Value();
}

_variant_t AsVariant(const Handle<Value> value)
{
	if (value->IsBoolean())
	{
		return value->BooleanValue();
	}
	else if (value->IsInt32())
	{
		return _variant_t((long)value->Int32Value(), VT_I4);
	}
	else if (value->IsNumber())
	{
		return value->NumberValue();
	}
	else if (value->IsString())
	{
		return (LPCSTR)::AsCString(value->ToString());
	}
	else
	{
		_ASSERT(value->IsNull());
		return NULL;
	}
}

_variant_t AsDateVariant(const Handle<Value> value)
{
	if (value->IsNumber())
	{
		double dDate = value->NumberValue();

		// Convert from milliseconds to days
		dDate /= 24 * 60 * 60 * 1000;

		static COleDateTime odtUnixEpoch(1970, 1, 1, 0, 0, 0);
		DATE dateForVariant = (DATE)dDate + (DATE)odtUnixEpoch;

		return _variant_t(dateForVariant, VT_DATE);
	}
	else
	{
		_ASSERT(value->IsNull());
		return NULL;
	}
}

Handle<Value> AsV8Value(const _variant_t vtValue)
{
	switch(vtValue.vt)
	{
	case VT_NULL:
		return Null(Isolate::GetCurrent());

	case VT_BSTR:
		return ::AsV8String(vtValue.bstrVal);

	case VT_I2:
	case VT_I4:
	case VT_INT:
		return Integer::New(Isolate::GetCurrent(), vtValue.intVal);

	case VT_R8:
		return Number::New(Isolate::GetCurrent(), vtValue.dblVal);

	case VT_BOOL:
		return Boolean::New(Isolate::GetCurrent(), vtValue.boolVal ? true : false);

	case VT_DATE:
		{
			static COleDateTime odtUnixEpoch(1970, 1, 1, 0, 0, 0);
			double d = (DATE)vtValue - (DATE)odtUnixEpoch;

			// Convert from days to milliseconds
			d *= 24 * 60 * 60 * 1000;

			return Number::New(Isolate::GetCurrent(), d);
		}

	default:
		{
			CString sMsg;
			sMsg.Format("*Type error %d*", vtValue.vt);

			if (vtValue.vt != VT_DECIMAL) // Warn if any unsupported types are used, except this one which I believe I can get away with ignoring
			{
				_ASSERT(false);
			}

			return ::AsV8String(sMsg);
		}
	}
}

void ThrowException(const CString& sError)
{
	Isolate::GetCurrent()->ThrowException(::AsV8String(sError));
}

CString DescribeVariant(const _variant_t vtValue)
{
	CString sValue = ::AsCString(::AsV8Value(vtValue));
	CString sType = "Unknown";
	CString sDescription;

	switch(vtValue.vt)
	{
	case VT_NULL:
		sType = "VT_NULL";
		break;

	case VT_BSTR:
		sType = "VT_BSTR";
		break;

	case VT_I2:
		sType = "VT_I2";
		break;

	case VT_I4:
		sType = "VT_I4";
		break;

	case VT_R8:
		sType = "VT_R8";
		break;

	case VT_INT:
		sType = "VT_INT";
		break;

	case VT_BOOL:
		sType = "VT_BOOL";
		break;

	case VT_DATE:
		sType = "VT_DATE";
		break;
	}

	sDescription.Format("'%s'(%s)", sValue, sType);
	return sDescription;
}

//
// PopulateFromRecordset
//
void PopulateFromRecordset(long nSchemaLevel, long nStartRecord, long nNumberOfRecordsToGet, bool bSpecialSchemaRecordset, ADODB::_RecordsetPtr rs, Handle<Object> oRoot)
{
	bool bMore = false;

	Handle<Array> arrRecords = Array::New(Isolate::GetCurrent());
	Handle<Array> arrFields  = Array::New(Isolate::GetCurrent());

	if (nSchemaLevel)
	{
		int nTotalSize = 0;

		class CFieldInfo
		{
		public:
			CFieldInfo(const CString& sName, int nSize)
				: m_sName(sName), m_nSize(nSize), m_nDefinedSize(0), m_bIsAutoIncrement(false)
			{}

			CString m_sName;
			int m_nSize;
			CString m_sType;
			long m_nDefinedSize;
			bool m_bIsAutoIncrement;
			CString m_sTablename;
		};

		std::vector<CFieldInfo> vecFieldInfo;

		for (long nField = 0; nField < rs->Fields->Count; ++nField)
		{
			ADODB::FieldPtr adoField = rs->Fields->Item[nField];

			CString sFieldname = (LPCTSTR)adoField->Name;
			int nSize = adoField->DefinedSize;

			if (nSize < 5)
			{
				nSize = 5;
			}
			else if (nSize > 25)
			{
				nSize = 25;
			}

			nTotalSize += nSize;
			vecFieldInfo.push_back(CFieldInfo(sFieldname, nSize));

			if (nSchemaLevel >= 2)
			{
				CFieldInfo& info = vecFieldInfo.back();

				long nType = adoField->Type;
				switch(nType)
				{
				case ADODB::adInteger:
					info.m_sType = "INTEGER";
					break;

				case ADODB::adBoolean:
					info.m_sType = "YESNO";
					break;

				case ADODB::adVarWChar:
					info.m_sType = _T("TEXT");
					break;

				case ADODB::adLongVarWChar:
					info.m_sType = "MEMO";
					break;

				case ADODB::adDate:
					info.m_sType = "DATE";
					break;

				default:
					info.m_sType.Format(_T("%d"), nType);
				}

				info.m_nDefinedSize = adoField->DefinedSize;

				ADODB::PropertiesPtr iProperties = adoField->GetProperties();
				for (long n = 0; n < iProperties->Count; ++n)
				{
					ADODB::PropertyPtr iProp = iProperties->GetItem(n);
					CString sName = (BSTR)iProp->GetName();

					if (sName == _T("ISAUTOINCREMENT"))
					{
						info.m_bIsAutoIncrement = iProp->GetValue().boolVal ? true : false;
					}
					else if (sName == _T("BASETABLENAME"))
					{
						_variant_t nvTablename = iProp->GetValue();
						info.m_sTablename = (nvTablename.vt == VT_BSTR) ? CString(nvTablename.bstrVal) : _T("");
					}
				}
			}
		}

		for (UINT nField = 0; nField < vecFieldInfo.size(); ++nField)
		{
			CFieldInfo& info = vecFieldInfo[nField];
			int nSize = (int)::ceil(info.m_nSize * 100.0 / nTotalSize);
			CString sSize;
			sSize.Format("%d%%", nSize);

			Handle<Object> oField = Object::New(Isolate::GetCurrent());
			oField->Set(::AsV8String("name"),  ::AsV8String(info.m_sName));
			oField->Set(::AsV8String("width"), ::AsV8String(sSize));

			if (nSchemaLevel >= 2)
			{
				oField->Set(::AsV8String("Type"), ::AsV8String(info.m_sType));
				oField->Set(::AsV8String("DefinedSize"), Integer::New(Isolate::GetCurrent(), info.m_nDefinedSize));
				oField->Set(::AsV8String("ISAUTOINCREMENT"), Boolean::New(Isolate::GetCurrent(), info.m_bIsAutoIncrement));
				oField->Set(::AsV8String("Tablename"), ::AsV8String(info.m_sTablename));
			}

			arrFields->Set(arrFields->Length(), oField);
		}
	}

	int nRecordCount = rs->RecordCount;

	if ( nRecordCount == -1 && bSpecialSchemaRecordset == false )
	{
		oRoot->Set(::AsV8String("Error"), ::AsV8String("Problem getting record count"));
	}
	else if ( ( (nStartRecord < nRecordCount) && (nStartRecord >= 0) ) || bSpecialSchemaRecordset )
	{
		if (nStartRecord == 0)
		{
			rs->MoveFirst();
		}
		else
		{
			rs->Move(nStartRecord, (long)ADODB::adBookmarkFirst);
		}

		while ( (rs->adoEOF == VARIANT_FALSE) && (nNumberOfRecordsToGet > 0) )
		{
			Handle<Object> oRecord = Object::New(Isolate::GetCurrent());

			for (long nField = 0; nField < rs->Fields->Count; ++nField)
			{
				ADODB::FieldPtr adoField = rs->Fields->Item[nField];
				CString sName = (LPCTSTR)adoField->Name;
				Handle<Value> value = ::AsV8Value(adoField->Value);
				oRecord->Set(::AsV8String(sName), value);
			}

			arrRecords->Set(arrRecords->Length(), oRecord);

			--nNumberOfRecordsToGet;
			rs->MoveNext();
		}

		if (rs->adoEOF == VARIANT_FALSE)
		{
			bMore = true;
		}
	}

	oRoot->Set(::AsV8String("more"), Boolean::New(Isolate::GetCurrent(), bMore));

	if (nSchemaLevel)
	{
		oRoot->Set(::AsV8String("fields"), arrFields);
	}

	oRoot->Set(::AsV8String("records"), arrRecords);
}

//
// selectSql
//
void selectSql(const FunctionCallbackInfo<Value>& args)
{
	HandleScope scope(Isolate::GetCurrent());

	if (args.Length() != 1 || args[0]->IsObject() == false)
	{
		::ThrowException("'selectSql' function expected one argument, which should be an object");
		return;
	}

	Handle<Value> vDatabaseFilename     = args[0]->ToObject()->Get(::AsV8String("databaseFilename"));
	Handle<Value> vQuery                = args[0]->ToObject()->Get(::AsV8String("query"));
	Handle<Value> vStartRecord          = args[0]->ToObject()->Get(::AsV8String("startRecord"));
	Handle<Value> vNumberOfRecordsToGet = args[0]->ToObject()->Get(::AsV8String("numberOfRecordsToGet"));
	Handle<Value> vSchemaLevel          = args[0]->ToObject()->Get(::AsV8String("schemaLevel"));

	CString sDatabaseFilename  = vDatabaseFilename->IsString()     ? ::AsCString(vDatabaseFilename)  : _T("");
	CString sQuery             = vQuery->IsString()                ? ::AsCString(vQuery)		     : _T("");
	long nStartRecord		   = vStartRecord->IsNumber()          ? ::AsLong(vStartRecord)          : 0;
	long nNumberOfRecordsToGet = vNumberOfRecordsToGet->IsNumber() ? ::AsLong(vNumberOfRecordsToGet) : 20;
	long nSchemaLevel          = vSchemaLevel->IsNumber()          ? ::AsLong(vSchemaLevel)          : 0;

	Handle<Object> oRoot = Object::New(Isolate::GetCurrent());

	if (sDatabaseFilename == _T(""))
	{
		oRoot->Set(::AsV8String("Error"), ::AsV8String("'selectSql' function expected 'databaseFilename' to be a non-empty string"));
	}
	else if (sQuery == _T(""))
	{
		oRoot->Set(::AsV8String("Error"), ::AsV8String("'selectSql' function expected 'query' to be a non-empty string"));
	}
	else
	{
		oRoot->Set(::AsV8String("query"), ::AsV8String(sQuery));
		oRoot->Set(::AsV8String("startRecord"), Integer::New(Isolate::GetCurrent(), nStartRecord));

		try
		{
			ADODB::_ConnectionPtr db("ADODB.Connection");
			db->Provider = "Microsoft.Jet.OLEDB.4.0";
			db->Open((LPCTSTR)sDatabaseFilename, "", "", 0);

			ADODB::_RecordsetPtr rs("ADODB.Recordset");
			rs->Open((LPCSTR)sQuery, (IDispatch *)db, ADODB::adOpenStatic, ADODB::adLockReadOnly, 0);

			PopulateFromRecordset(nSchemaLevel, nStartRecord, nNumberOfRecordsToGet, false, rs, oRoot);

			rs->Close();
			db->Close();
		}
		catch(_com_error &e)
		{
			oRoot->Set(::AsV8String("Error"), ::AsV8String((LPCTSTR)e.Description()));
		}
		catch(...)
		{
			oRoot->Set(::AsV8String("Error"), ::AsV8String("Unidentified exception"));
		}
	}

	args.GetReturnValue().Set(oRoot);
}

//
// updateDatabase
//
void updateDatabase(const FunctionCallbackInfo<Value>& args)
{
	HandleScope scope(Isolate::GetCurrent());

	if (args.Length() != 2 || args[0]->IsString() == false || args[1]->IsArray() == false)
	{
		::ThrowException("'updateDatabase' function expected two arguments, a database filename string and an array of the update details");
		return;
	}

	CString sDatabaseFilename = ::AsCString(args[0]->ToString());
	Handle<Array> arrSql = Handle<Array>::Cast(args[1]->ToObject());

	Handle<Object> oReturnValue = Object::New(Isolate::GetCurrent());

	ADODB::_ConnectionPtr db;

	try
	{
		db = ADODB::_ConnectionPtr("ADODB.Connection");
		db->Provider = "Microsoft.Jet.OLEDB.4.0";
		db->Open((LPCTSTR)sDatabaseFilename, "", "", 0);

		db->BeginTrans();
	}
	catch(_com_error &e)
	{
		oReturnValue->Set(::AsV8String("Error"), ::AsV8String((LPCTSTR)e.Description()));
		args.GetReturnValue().Set(oReturnValue);
		return;
	}
	catch(...)
	{
		oReturnValue->Set(::AsV8String("Error"), ::AsV8String("Unidentified exception"));
		args.GetReturnValue().Set(oReturnValue);
		return;
	}

	bool bOK = true; // OK so far ;-)

	for (UINT nSql = 0; nSql < arrSql->Length(); ++nSql)
	{
		Handle<Value> vSql = arrSql->Get(nSql);

		if (!vSql->IsObject())
		{
			CString sError;
			sError.Format(_T("'updateDatabase' function, item %d is not an object"), nSql);
			::ThrowException(sError);
			return;
		}

		Handle<Object> oSql = vSql->ToObject();
		Handle<Value> vTable = oSql->Get(::AsV8String("table"));
		Handle<Value> vOperations = oSql->Get(::AsV8String("operations"));

		if (!vTable->IsString())
		{
			CString sError;
			sError.Format(_T("'updateDatabase' function, item %d 'table' is not a string"), nSql);
			::ThrowException(sError);
			bOK = false;
		}
		else if (!vOperations->IsArray())
		{
			CString sError;
			sError.Format(_T("'updateDatabase' function, item %d 'operations' is not an array"), nSql);
			::ThrowException(sError);
			bOK = false;
		}
		else
		{
			CString sTable = ::AsCString(vTable->ToString());
			Handle<Array> arrOperations = Handle<Array>::Cast(vOperations);

			try
			{
				ADODB::_RecordsetPtr rs("ADODB.Recordset");
				rs->Open((LPCSTR)sTable, (IDispatch *)db, ADODB::adOpenStatic, ADODB::adLockOptimistic, ADODB::adCmdTableDirect);

				for (UINT nOperation = 0; nOperation < arrOperations->Length(); ++nOperation)
				{
					Handle<Value> vOperation = arrOperations->Get(nOperation);

					if (!vOperation->IsObject())
					{
						CString sError;
						sError.Format(_T("'updateDatabase' function, item %d, operation %d is not an object"), nSql, nOperation);
						::ThrowException(sError);
						bOK = false;
						break;
					}

					Handle<Object> oOperation = vOperation->ToObject();
					Handle<Value> vOperationName = oOperation->Get(::AsV8String("operationName"));
					Handle<Value> vOldRecord = oOperation->Get(::AsV8String("oldRecord"));
					Handle<Value> vNewRecord = oOperation->Get(::AsV8String("newRecord"));

					if (!vOperationName->IsString())
					{
						CString sError;
						sError.Format(_T("'updateDatabase' function, item %d, operation %d, operationName is not a string"),
									  nSql,
									  nOperation);

						::ThrowException(sError);
						bOK = false;
						break;
					}

					CString sOperationName = ::AsCString(vOperationName->ToString());

					if (sOperationName == "add")
					{
						if (!vNewRecord->IsObject())
						{
							CString sError;
							sError.Format(_T("'updateDatabase' function, item %d, operation %d (add), field 'newRecord' not found"), nSql, nOperation);
							::ThrowException(sError);
							bOK = false;
							break;
						}

						rs->AddNew();

						Handle<Object> oNewRecord = vNewRecord->ToObject();
						Handle<Array> arrNewRecord = oNewRecord->GetPropertyNames();

						for (UINT nFld = 0; nFld < arrNewRecord->Length(); ++nFld)
						{
							Handle<Value> vFieldname = arrNewRecord->Get(nFld);
							_variant_t vtFieldname = ::AsVariant(vFieldname);

							Handle<Value> vNewValue = oNewRecord->Get(vFieldname);

							try
							{
								ADODB::FieldPtr iField = rs->Fields->GetItem(vtFieldname);

								_variant_t vtNewValue;

								switch (iField->GetType())
								{
								case ADODB::adDate:
								case ADODB::adDBDate:
								case ADODB::adDBTime:
								case ADODB::adDBTimeStamp:
									vtNewValue = ::AsDateVariant(vNewValue);
									break;

								default:
									vtNewValue = ::AsVariant(vNewValue);
								}

								iField->PutValue(vtNewValue);
							}
							catch(_com_error &e)
							{
								bOK = false;
								CString sError;
								sError.Format(_T("Couldn't write field '%s', value '%s': %s"),
											  (CString)vtFieldname.bstrVal,
											  ::AsCString(vNewValue),
											  (CString)(BSTR)e.Description());

								oReturnValue->Set(::AsV8String("Error"), ::AsV8String(sError));
							}
						}

						if (bOK)
						{
							rs->Update();
						}
						else
						{
							rs->CancelUpdate();
						}

					}
					else if (sOperationName == "edit")
					{
						if (!vOldRecord->IsObject())
						{
							CString sError;
							sError.Format(_T("'updateDatabase' function, item %d, operation %d, field 'oldRecord' not found"), nSql, nOperation);
							::ThrowException(sError);
							bOK = false;
							break;
						}

						if (!vNewRecord->IsObject())
						{
							CString sError;
							sError.Format(_T("'updateDatabase' function, item %d, operation %d (edit), field 'newRecord' not found"), nSql, nOperation);
							::ThrowException(sError);
							bOK = false;
							break;
						}

						Handle<Object> oOldRecord = vOldRecord->ToObject();
						Handle<Object> oNewRecord = vNewRecord->ToObject();

						// Let's go looking for the auto-increment field.  I'd rather be looking for the primary key,
						// but let's face it - I'd rather not be using COM, ADO and JET in the first place!

						CString sAutoIncrementFieldName;
						bool bGotIndex = false;

						for (long nFld = 0; nFld < rs->Fields->GetCount(); ++nFld)
						{
							ADODB::FieldPtr fld = rs->Fields->GetItem(nFld);
							_variant_t vt = fld->GetProperties()->GetItem("ISAUTOINCREMENT")->GetValue();
							if (vt.vt == VT_BOOL && vt.boolVal == VARIANT_TRUE)
							{
								sAutoIncrementFieldName = (LPCSTR)fld->GetName();
							}
						}

						_variant_t arrKeyValues[1];
						int nAutoIncrementValue = 0;

						if (sAutoIncrementFieldName.GetLength())
						{
							Handle<Value> vField = oOldRecord->Get(::AsV8String(sAutoIncrementFieldName));
							nAutoIncrementValue = vField->Int32Value();

							arrKeyValues[0] = nAutoIncrementValue;

							try
							{
								rs->PutIndex("PrimaryKey");
								bGotIndex = true;
							}
							catch (_com_error &e)
							{
								if (e.Error() != DB_E_NOINDEX)
								{
									// We're only interested in handling one error here, and this ain't it, so throw it
									// (it gets caught and properly reported futher down).
									throw;
								}
							}
						}

						if (bGotIndex == false)
						{
							// No primary key.  Hit the entire table looking for the single row we wish to update.
							// This is obviously inefficient, but that's what you get for not defining a primary key.

							bool bMatchFound = false;

							rs->MoveFirst();

							while (rs->adoEOF == false)
							{
								bool bThisRecordMatches = true;

								for (long nFld = 0; nFld < rs->Fields->GetCount(); ++nFld)
								{
									ADODB::FieldPtr fld = rs->Fields->GetItem(nFld);
									CString sFieldName = (LPCSTR)fld->GetName();
									Handle<String> strFieldName = ::AsV8String(sFieldName);
									_variant_t vtExpectedValue = fld->GetValue();
									_variant_t vtOldValue;
									
									switch (fld->GetType())
									{
									case ADODB::adDate:
									case ADODB::adDBDate:
									case ADODB::adDBTime:
									case ADODB::adDBTimeStamp:
										vtOldValue = ::AsDateVariant(oOldRecord->Get(strFieldName));
										break;

									default:
										vtOldValue = ::AsVariant(oOldRecord->Get(strFieldName));
									}


									if (vtOldValue != vtExpectedValue)
									{
										bThisRecordMatches = false;
										break;
									}
								}

								if (bThisRecordMatches)
								{
									for (long nFld = 0; nFld < rs->Fields->GetCount(); ++nFld)
									{
										ADODB::FieldPtr fld = rs->Fields->GetItem(nFld);
										CString sFieldName = (LPCSTR)fld->GetName();
										if (sFieldName != sAutoIncrementFieldName)
										{
											_variant_t vtExpectedValue = fld->GetValue();
											_variant_t vtNewValue = ::AsVariant(oNewRecord->Get(::AsV8String(sFieldName)));
											fld->PutValue(vtNewValue);
										}
									}

									rs->Update();

									bMatchFound = true;
									break;
								}
								rs->MoveNext();
							}

							if (bMatchFound == false)
							{
								CString sError = _T("Can't perform update because this record could not be found.  (usually because the record has already been changed or deleted)");

								oReturnValue->Set(::AsV8String("Error"), ::AsV8String(sError));
							}
						}
						else
						{
							rs->Seek(arrKeyValues, ADODB::adSeekFirstEQ);

							if (rs->adoEOF)
							{
								CString sError;
								sError.Format(_T("'updateDatabase' function, item %d, operation %d database record (%s=%d) not found"), nSql, nOperation, sAutoIncrementFieldName, nAutoIncrementValue);
								oReturnValue->Set(::AsV8String("Error"), ::AsV8String(sError));
								bOK = false;
								break;
							}

							for (long nFld = 0; nFld < rs->Fields->GetCount(); ++nFld)
							{
								ADODB::FieldPtr fld = rs->Fields->GetItem(nFld);
								CString sFieldName = (LPCSTR)fld->GetName();
								_variant_t vtExpectedValue = fld->GetValue();
								_variant_t vtOldValue = ::AsVariant(oOldRecord->Get(::AsV8String(sFieldName)));
								
								Handle<Value> value = oNewRecord->Get(::AsV8String(sFieldName));

								if (value->IsUndefined())
								{
									continue;
								}

								_variant_t vtNewValue = ::AsVariant(oNewRecord->Get(::AsV8String(sFieldName)));

								if (vtOldValue != vtExpectedValue)
								{
									// This issue is actually expected to occur in userland from time to time.
									// (nearly every other error indicates a software problem)

									CString sError;
									sError.Format(_T("Can't perform update because record has already changed.  Field '%s', actual value %s, expected %s, can't change to %s"),
												  sFieldName,
												  DescribeVariant(vtExpectedValue),
												  DescribeVariant(vtOldValue),
												  DescribeVariant(vtNewValue));

									oReturnValue->Set(::AsV8String("Error"), ::AsV8String(sError));
									bOK = false;
									break;
								}

								if (vtOldValue != vtNewValue && sFieldName != sAutoIncrementFieldName)
								{
									fld->PutValue(vtNewValue);
								}
							}

							if (bOK)
							{
								rs->Update();
							}
							else
							{
								rs->CancelUpdate();
							}
						}

					}
					else
					{
						CString sError;
						sError.Format(_T("'updateDatabase' function, item %d, operation %d, operationName '%s' not recognised"), nSql, nOperation, sOperationName);
						::ThrowException(sError);
						bOK = false;
						break;
					}
				}

				rs->Close();
			}
			catch(_com_error &e)
			{
				if (bOK)
				{
					oReturnValue->Set(::AsV8String("Error"), ::AsV8String((LPCTSTR)e.Description()));
					bOK = false;
				}
			}
			catch(...)
			{
				if (bOK)
				{
					oReturnValue->Set(::AsV8String("Error"), ::AsV8String("Unidentified exception"));
					bOK = false;
				}
			}
		}

		if (bOK == false)
		{
			break;
		}
	}

	try
	{
		if (bOK)
		{
			db->CommitTrans();
		}
		else
		{
			db->RollbackTrans();
		}

		db->Close();
	}
	catch(_com_error &e)
	{
		oReturnValue->Set(::AsV8String("Error"), ::AsV8String((LPCTSTR)e.Description()));
	}
	catch(...)
	{
		oReturnValue->Set(::AsV8String("Error"), ::AsV8String("Unidentified exception"));
	}

	args.GetReturnValue().Set(oReturnValue);
}

//
// getIndices
//
void getIndices(const FunctionCallbackInfo<Value>& args)
{
	HandleScope scope(Isolate::GetCurrent());

	if (args.Length() != 1 || args[0]->IsString() == false)
	{
		::ThrowException("'getIndices' function expected one argument, which should be a database filename string");
		return;
	}

	CString sDatabaseFilename = ::AsCString(args[0]->ToString());

	Handle<Object> oRoot = Object::New(Isolate::GetCurrent());

	try
	{
		ADODB::_ConnectionPtr db("ADODB.Connection");
		db->Provider = "Microsoft.Jet.OLEDB.4.0";
		db->Open((LPCTSTR)sDatabaseFilename, "", "", 0);

		ADODB::_RecordsetPtr rs = db->OpenSchema(ADODB::adSchemaIndexes);

		PopulateFromRecordset(0, 0, 1000, true, rs, oRoot);

		rs->Close();
		db->Close();
	}
	catch(_com_error &e)
	{
		oRoot->Set(::AsV8String("Error"), ::AsV8String((LPCTSTR)e.Description()));
	}
	catch(...)
	{
		oRoot->Set(::AsV8String("Error"), ::AsV8String("Unidentified exception"));
	}

	args.GetReturnValue().Set(oRoot);
}

//
// runSql
//
void runSql(const FunctionCallbackInfo<Value>& args)
{
	HandleScope scope(Isolate::GetCurrent());

	if (args.Length() != 2 || args[0]->IsString() == false || args[1]->IsArray() == false)
	{
		::ThrowException("'runSql' function expected two arguments, a database filename string, and an array of SQL statement strings");
		return;
	}

	CString sDatabaseFilename = ::AsCString(args[0]->ToString());
	Handle<Array> arrSql = Handle<Array>::Cast(args[1]->ToObject());

	try
	{
		ADODB::_ConnectionPtr db("ADODB.Connection");
		db->Provider = "Microsoft.Jet.OLEDB.4.0";
		db->Open((LPCTSTR)sDatabaseFilename, "", "", 0);

		for (UINT n = 0; n < arrSql->Length(); ++n)
		{
			Handle<Value> v = arrSql->Get(n);
			if (v->IsString())
			{
				CString sSql = ::AsCString(v);
                db->Execute(_bstr_t(sSql), NULL, 0);
			}
			else
			{
				CString sMsg;
				sMsg.Format(_T("'runSql' function found item at array index %d which was is not a string"), n);
				break;
			}
		}

		db->Close();
	}
	catch(_com_error &e)
	{
		CString sMsg;
		sMsg.Format(_T("'runSql' function encountered an error: %s"), CString(e.Description().GetBSTR()));
		::ThrowException(sMsg);
	}
	catch(...)
	{
		::ThrowException("'runSql' function encountered an unidentified exception");
	}

	return;
}

//
// init
//
void init(Handle<Object> exports)
{
	::CoInitialize(NULL);
	NODE_SET_METHOD(exports, "selectSql",      selectSql);
	NODE_SET_METHOD(exports, "updateDatabase", updateDatabase);
	NODE_SET_METHOD(exports, "getIndices",     getIndices);
	NODE_SET_METHOD(exports, "runSql",         runSql);
}

NODE_MODULE(dface, init)


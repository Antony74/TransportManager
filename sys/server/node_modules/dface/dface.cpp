#pragma warning (disable: 4506) // v8 can probably be forgiven this nonsense: no definition for inline function 'v8::Persistent<T> v8::Persistent<T>::New(v8::Handle<T>)
#pragma warning (disable: 4530) // This is a node-gyp issue: C++ exception handler used, but unwind semantics are not enabled. Specify /EHsc

#define WINVER 0x0600

#include <afxdisp.h>

#include <node.h>
#include <v8.h>
using namespace v8;

#import "C:\Program Files\Common Files\System\ado\msado15.dll" rename( "EOF", "adoEOF" )
#include <atlstr.h>

#include <vector>
#include <math.h>

CString AsCString(Local<Value> value)
{
	CString s;
	Local<String> str = value->ToString();
	value->ToString()->WriteAscii(s.GetBuffer(str->Length()));
	s.ReleaseBuffer();
	return s;
}

long AsLong(Local<Value> value)
{
	return (long)value->ToInteger()->Value();
}

Handle<Value> selectSql(const Arguments& args)
{
	HandleScope scope;

	if (args.Length() != 1 || args[0]->IsObject() == false)
	{
		ThrowException(Exception::Error(String::New("'selectSql' function expected one argument, which should be an object")));
		return scope.Close(Undefined());
	}

	Local<Value> vDatabaseFilename     = args[0]->ToObject()->Get(String::NewSymbol("databaseFilename"));
	Local<Value> vQuery                = args[0]->ToObject()->Get(String::NewSymbol("query"));
	Local<Value> vStartRecord          = args[0]->ToObject()->Get(String::NewSymbol("startRecord"));
	Local<Value> vNumberOfRecordsToGet = args[0]->ToObject()->Get(String::NewSymbol("numberOfRecordsToGet"));
	Local<Value> vSchemaLevel          = args[0]->ToObject()->Get(String::NewSymbol("schemaLevel"));

	CString sDatabaseFilename  = vDatabaseFilename->IsString()     ? AsCString(vDatabaseFilename)  : _T("");
	CString sQuery             = vQuery->IsString()                ? AsCString(vQuery)			   : _T("");
	long nStartRecord		   = vStartRecord->IsNumber()          ? AsLong(vStartRecord)          : 0;
	long nNumberOfRecordsToGet = vNumberOfRecordsToGet->IsNumber() ? AsLong(vNumberOfRecordsToGet) : 20;
	long nSchemaLevel          = vSchemaLevel->IsNumber()          ? AsLong(vSchemaLevel)          : 0;

	Handle<Object> oRoot = Object::New();
	oRoot->Set(String::New("query"), String::New(sQuery));
	oRoot->Set(String::New("startRecord"), Integer::New(nStartRecord));
	bool bMore = false;
	
	Handle<Array> arrRecords = Array::New();
	Handle<Array> arrFields  = Array::New();

	try
	{
		ADODB::_ConnectionPtr db("ADODB.Connection");
		db->Provider = "Microsoft.Jet.OLEDB.4.0";
		db->Open((LPCTSTR)sDatabaseFilename, "", "", 0);

		ADODB::_RecordsetPtr rs("ADODB.Recordset");
		rs->Open((LPCSTR)sQuery, (IDispatch *)db, ADODB::adOpenStatic, ADODB::adLockUnspecified, 0);

		if (nSchemaLevel)
		{
			int nTotalSize = 0;

			class CFieldInfo
			{
			public:
				CFieldInfo(const CString& sName, int nSize)
					: m_sName(sName), m_nSize(nSize)
				{}

				CString m_sName;
				int m_nSize;
			};

			std::vector<CFieldInfo> vecFieldInfo;

			for (long nField = 0; nField < rs->Fields->Count; ++nField)
			{
				ADODB::FieldPtr adoField = rs->Fields->Item[nField];

				CString sFieldname = (LPCTSTR)adoField->Name;
				int nSize = adoField->DefinedSize;

				if (nSize < 5)
				{
					nSize = 5;
				}
				else if (nSize > 25)
				{
					nSize = 25;
				}

				nTotalSize += nSize;
				vecFieldInfo.push_back(CFieldInfo(sFieldname, nSize));
			}

			for (UINT nField = 0; nField < vecFieldInfo.size(); ++nField)
			{
				CFieldInfo& info = vecFieldInfo[nField];
				int nSize = (int)::ceil(info.m_nSize * 100.0 / nTotalSize);
				CString sSize;
				sSize.Format("%d%%", nSize);

				Handle<Object> oField = Object::New();
				oField->Set(String::New("name"), String::New(info.m_sName));
				oField->Set(String::New("width"), String::New(sSize));
				arrFields->Set(arrFields->Length(), oField);
			}
		}

		int nRecordCount = rs->RecordCount;

		if (nRecordCount == -1)
		{
			oRoot->Set(String::New("error"), String::New("Problem getting record count"));
		}
		else if ( (nStartRecord < nRecordCount) && (nStartRecord >= 0) )
		{
			rs->Move(nStartRecord, (long)ADODB::adBookmarkFirst);

			while ( (rs->adoEOF == VARIANT_FALSE) && (nNumberOfRecordsToGet > 1) )
			{
				Handle<Object> oRecord = Object::New();

				for (long nField = 0; nField < rs->Fields->Count; ++nField)
				{
					ADODB::FieldPtr adoField = rs->Fields->Item[nField];
					CString sName = (LPCTSTR)adoField->Name;
					_variant_t vtValue = adoField->Value;

					switch(vtValue.vt)
					{
					case VT_NULL:
						oRecord->Set(String::New(sName), String::New(""));

					case VT_BSTR:
						oRecord->Set(String::New(sName), String::New((CString)vtValue.bstrVal));
						break;

					case VT_I4:
						oRecord->Set(String::New(sName), Integer::New(vtValue.intVal));
						break;

					case VT_BOOL:
						oRecord->Set(String::New(sName), Boolean::New(vtValue.boolVal ? true : false));
						break;

					case VT_DATE:
						{
							COleDateTime odt(vtValue.date);
							Local<String> strDate;
							if ((DATE)odt < 10.0)
							{
								strDate = String::New("");
							}
							else if (odt.GetHour() == 0 && odt.GetMinute() == 0)
							{
								strDate = String::New(odt.Format("%d/%m/%Y"));
							}
							else
							{
								strDate = String::New(odt.Format("%d/%m/%Y %H:%M:%S"));
							}

							oRecord->Set(String::New(sName), strDate);
						}
						break;

					default:
						{
							CString sMsg;
							sMsg.Format("*Type error %d*", vtValue.vt);
							oRecord->Set(String::New(sName), String::New(sMsg));
						}
					}

				}

				arrRecords->Set(arrRecords->Length(), oRecord);

				--nNumberOfRecordsToGet;
				rs->MoveNext();
			}

			if (rs->adoEOF == VARIANT_FALSE)
			{
				bMore = true;
			}
		}

		rs->Close();
		db->Close();
	}
	catch(_com_error &e)
	{
		oRoot->Set(String::New("error"), String::New(e.Description()));
	}
	catch(...)
	{
		oRoot->Set(String::New("error"), String::New("Unidentified exception"));
	}

	oRoot->Set(String::New("more"), Boolean::New(bMore));

	if (nSchemaLevel)
	{
		oRoot->Set(String::New("fields"), arrFields);
	}

	oRoot->Set(String::New("records"), arrRecords);

	return scope.Close(oRoot);
}

void init(Handle<Object> exports)
{
	::CoInitialize(NULL);
	exports->Set(String::NewSymbol("selectSql"), FunctionTemplate::New(selectSql)->GetFunction());
}

NODE_MODULE(dface, init)

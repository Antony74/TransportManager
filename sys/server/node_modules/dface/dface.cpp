#pragma warning (disable: 4506) // v8 can probably be forgiven this nonsense: no definition for inline function 'v8::Persistent<T> v8::Persistent<T>::New(v8::Handle<T>)
#pragma warning (disable: 4530) // This is a node-gyp issue: C++ exception handler used, but unwind semantics are not enabled. Specify /EHsc

#define WINVER 0x0600

#include <afxdisp.h>

#include <node.h>
#include <v8.h>
using namespace v8;

#import "C:\Program Files\Common Files\System\ado\msado15.dll" rename( "EOF", "adoEOF" )
#include <atlstr.h>

#include <vector>
#include <math.h>

CString AsCString(Local<Value> value)
{
	CString s;
	Local<String> str = value->ToString();
	value->ToString()->WriteAscii(s.GetBuffer(str->Length()));
	s.ReleaseBuffer();
	return s;
}

long AsLong(Local<Value> value)
{
	return (long)value->ToInteger()->Value();
}

//
// PopulateFromRecordset
//
void PopulateFromRecordset(long nSchemaLevel, long nStartRecord, long nNumberOfRecordsToGet, bool bSpecialSchemaRecordset, ADODB::_RecordsetPtr rs, Handle<Object> oRoot)
{
	bool bMore = false;

	Handle<Array> arrRecords = Array::New();
	Handle<Array> arrFields  = Array::New();

	if (nSchemaLevel)
	{
		int nTotalSize = 0;

		class CFieldInfo
		{
		public:
			CFieldInfo(const CString& sName, int nSize)
				: m_sName(sName), m_nSize(nSize), m_nDefinedSize(0)
			{}

			CString m_sName;
			int m_nSize;
			CString m_sType;
			long m_nDefinedSize;
		};

		std::vector<CFieldInfo> vecFieldInfo;

		for (long nField = 0; nField < rs->Fields->Count; ++nField)
		{
			ADODB::FieldPtr adoField = rs->Fields->Item[nField];

			CString sFieldname = (LPCTSTR)adoField->Name;
			int nSize = adoField->DefinedSize;

			if (nSize < 5)
			{
				nSize = 5;
			}
			else if (nSize > 25)
			{
				nSize = 25;
			}

			nTotalSize += nSize;
			vecFieldInfo.push_back(CFieldInfo(sFieldname, nSize));

			if (nSchemaLevel >= 2)
			{
				CFieldInfo& info = vecFieldInfo.back();

				long nType = adoField->Type;
				switch(nType)
				{
				case ADODB::adInteger:
					info.m_sType = "INTEGER";
					break;

				case ADODB::adBoolean:
					info.m_sType = "YESNO";
					break;

				case ADODB::adVarWChar:
					info.m_sType = _T("TEXT");
					break;

				case ADODB::adLongVarWChar:
					info.m_sType = "MEMO";
					break;

				case ADODB::adDate:
					info.m_sType = "DATE";
					break;

				default:
					info.m_sType.Format(_T("%d"), nType);
				}

				info.m_nDefinedSize = adoField->DefinedSize;
			}
		}

		for (UINT nField = 0; nField < vecFieldInfo.size(); ++nField)
		{
			CFieldInfo& info = vecFieldInfo[nField];
			int nSize = (int)::ceil(info.m_nSize * 100.0 / nTotalSize);
			CString sSize;
			sSize.Format("%d%%", nSize);

			Handle<Object> oField = Object::New();
			oField->Set(String::New("name"), String::New(info.m_sName));
			oField->Set(String::New("width"), String::New(sSize));

			if (nSchemaLevel >= 2)
			{
				oField->Set(String::New("Type"), String::New(info.m_sType));
				oField->Set(String::New("DefinedSize"), Integer::New(info.m_nDefinedSize));
			}

			arrFields->Set(arrFields->Length(), oField);
		}
	}

	int nRecordCount = rs->RecordCount;

	ADODB::CursorTypeEnum cursor = rs->CursorType;

	if ( nRecordCount == -1 && bSpecialSchemaRecordset == false )
	{
		oRoot->Set(String::New("Error"), String::New("Problem getting record count"));
	}
	else if ( ( (nStartRecord < nRecordCount) && (nStartRecord >= 0) ) || bSpecialSchemaRecordset )
	{
		if (nStartRecord == 0)
		{
			rs->MoveFirst();
		}
		else
		{
			rs->Move(nStartRecord, (long)ADODB::adBookmarkFirst);
		}

		while ( (rs->adoEOF == VARIANT_FALSE) && (nNumberOfRecordsToGet > 1) )
		{
			Handle<Object> oRecord = Object::New();

			for (long nField = 0; nField < rs->Fields->Count; ++nField)
			{
				ADODB::FieldPtr adoField = rs->Fields->Item[nField];
				CString sName = (LPCTSTR)adoField->Name;
				_variant_t vtValue = adoField->Value;

				switch(vtValue.vt)
				{
				case VT_NULL:
					oRecord->Set(String::New(sName), String::New(""));

				case VT_BSTR:
					oRecord->Set(String::New(sName), String::New((CString)vtValue.bstrVal));
					break;

				case VT_I2:
				case VT_I4:
					oRecord->Set(String::New(sName), Integer::New(vtValue.intVal));
					break;

				case VT_R8:
					oRecord->Set(String::New(sName), Number::New(vtValue.dblVal));
					break;

				case VT_BOOL:
					oRecord->Set(String::New(sName), Boolean::New(vtValue.boolVal ? true : false));
					break;

				case VT_DATE:
					{
						COleDateTime odt(vtValue.date);
						Local<String> strDate;
						if ((DATE)odt < 10.0)
						{
							strDate = String::New("");
						}
						else if (odt.GetHour() == 0 && odt.GetMinute() == 0)
						{
							strDate = String::New(odt.Format("%d/%m/%Y"));
						}
						else
						{
							strDate = String::New(odt.Format("%d/%m/%Y %H:%M:%S"));
						}

						oRecord->Set(String::New(sName), strDate);
					}
					break;

				default:
					{
						CString sMsg;
						sMsg.Format("*Type error %d*", vtValue.vt);
						oRecord->Set(String::New(sName), String::New(sMsg));

						if (vtValue.vt != VT_DECIMAL) // Warn if any unsupported types are used, except this one which I believe I can get away with ignoring
						{
							_ASSERT(false);
						}
					}
				}

			}

			arrRecords->Set(arrRecords->Length(), oRecord);

			--nNumberOfRecordsToGet;
			rs->MoveNext();
		}

		if (rs->adoEOF == VARIANT_FALSE)
		{
			bMore = true;
		}
	}

	oRoot->Set(String::New("more"), Boolean::New(bMore));

	if (nSchemaLevel)
	{
		oRoot->Set(String::New("fields"), arrFields);
	}

	oRoot->Set(String::New("records"), arrRecords);
}

//
// selectSql
//
Handle<Value> selectSql(const Arguments& args)
{
	HandleScope scope;

	if (args.Length() != 1 || args[0]->IsObject() == false)
	{
		ThrowException(Exception::Error(String::New("'selectSql' function expected one argument, which should be an object")));
		return scope.Close(Undefined());
	}

	Local<Value> vDatabaseFilename     = args[0]->ToObject()->Get(String::NewSymbol("databaseFilename"));
	Local<Value> vQuery                = args[0]->ToObject()->Get(String::NewSymbol("query"));
	Local<Value> vStartRecord          = args[0]->ToObject()->Get(String::NewSymbol("startRecord"));
	Local<Value> vNumberOfRecordsToGet = args[0]->ToObject()->Get(String::NewSymbol("numberOfRecordsToGet"));
	Local<Value> vSchemaLevel          = args[0]->ToObject()->Get(String::NewSymbol("schemaLevel"));

	CString sDatabaseFilename  = vDatabaseFilename->IsString()     ? ::AsCString(vDatabaseFilename) : _T("");
	CString sQuery             = vQuery->IsString()                ? ::AsCString(vQuery)		    : _T("");
	long nStartRecord		   = vStartRecord->IsNumber()          ? AsLong(vStartRecord)           : 0;
	long nNumberOfRecordsToGet = vNumberOfRecordsToGet->IsNumber() ? AsLong(vNumberOfRecordsToGet)  : 20;
	long nSchemaLevel          = vSchemaLevel->IsNumber()          ? AsLong(vSchemaLevel)           : 0;

	Handle<Object> oRoot = Object::New();
	oRoot->Set(String::New("query"), String::New(sQuery));
	oRoot->Set(String::New("startRecord"), Integer::New(nStartRecord));

	try
	{
		ADODB::_ConnectionPtr db("ADODB.Connection");
		db->Provider = "Microsoft.Jet.OLEDB.4.0";
		db->Open((LPCTSTR)sDatabaseFilename, "", "", 0);

		ADODB::_RecordsetPtr rs("ADODB.Recordset");
		rs->Open((LPCSTR)sQuery, (IDispatch *)db, ADODB::adOpenStatic, ADODB::adLockUnspecified, 0);

		PopulateFromRecordset(nSchemaLevel, nStartRecord, nNumberOfRecordsToGet, false, rs, oRoot);

		rs->Close();
		db->Close();
	}
	catch(_com_error &e)
	{
		oRoot->Set(String::New("Error"), String::New(e.Description()));
	}
	catch(...)
	{
		oRoot->Set(String::New("Error"), String::New("Unidentified exception"));
	}

	return scope.Close(oRoot);
}

//
// updateDatabase
//
Handle<Value> updateDatabase(const Arguments& args)
{
	HandleScope scope;

	if (args.Length() != 2 || args[0]->IsString() == false || args[1]->IsArray() == false)
	{
		ThrowException(Exception::Error(String::New("'updateDatabase' function expected two arguments, a database filename string and an array of the update details")));
		return scope.Close(Undefined());
	}

	CString sDatabaseFilename = ::AsCString(args[0]->ToString());
	Handle<Array> arrSql(Array::Cast(*args[1]->ToObject()));

	Handle<Object> oReturnValue = Object::New();

	ADODB::_ConnectionPtr db;

	try
	{
		db = ADODB::_ConnectionPtr("ADODB.Connection");
		db->Provider = "Microsoft.Jet.OLEDB.4.0";
		db->Open((LPCTSTR)sDatabaseFilename, "", "", 0);

		db->BeginTrans();
	}
	catch(_com_error &e)
	{
		oReturnValue->Set(String::New("Error"), String::New(e.Description()));
		return scope.Close(oReturnValue);
	}
	catch(...)
	{
		oReturnValue->Set(String::New("Error"), String::New("Unidentified exception"));
		return scope.Close(oReturnValue);
	}

	bool bOK = true; // OK so far ;-)

	for (UINT nSql = 0; nSql < arrSql->Length(); ++nSql)
	{
		Handle<Value> vSql = arrSql->Get(nSql);

		if (!vSql->IsObject())
		{
			CString sError;
			sError.Format(_T("'updateDatabase' function, item %d is not an object"), nSql);
			ThrowException(Exception::Error(String::New(sError)));
			return scope.Close(Undefined());
		}

		Handle<Object> oSql = vSql->ToObject();
		Handle<Value> vQuery = oSql->Get(String::New("query"));
		Handle<Value> vOperations = oSql->Get(String::New("operations"));

		if (!vQuery->IsString())
		{
			CString sError;
			sError.Format(_T("'updateDatabase' function, item %d 'query' is not a string"), nSql);
			ThrowException(Exception::Error(String::New(sError)));
			bOK = false;
		}
		else if (!vOperations->IsArray())
		{
			CString sError;
			sError.Format(_T("'updateDatabase' function, item %d 'operations' is not an array"), nSql);
			ThrowException(Exception::Error(String::New(sError)));
			bOK = false;
		}
		else
		{
			CString sQuery = ::AsCString(vQuery->ToString());
			Handle<Array> arrOperations(Array::Cast(*vOperations));

			try
			{
				ADODB::_RecordsetPtr rs("ADODB.Recordset");
				rs->Open((LPCSTR)sQuery, (IDispatch *)db, ADODB::adOpenStatic, ADODB::adLockUnspecified, 0);

				for (UINT nOperation = 0; nOperation < arrOperations->Length(); ++nOperation)
				{
					Handle<Value> vOperation = arrOperations->Get(nOperation);

					if (!vOperation->IsObject())
					{
						CString sError;
						sError.Format(_T("'updateDatabase' function, item %d, operation %d is not an object"), nSql, nOperation);
						ThrowException(Exception::Error(String::New(sError)));
						bOK = false;
						break;
					}

					Handle<Object> oOperation = vOperation->ToObject();
					Handle<Value> vOperationName = oOperation->Get(String::New("operation"));
					Handle<Value> vOldRecord = oOperation->Get(String::New("oldRecord"));
					Handle<Value> vNewRecord = oOperation->Get(String::New("newRecord"));

					if (!vOperationName->IsString())
					{
						CString sError;
						sError.Format(_T("'updateDatabase' function, item %d, operation %d, operation name is not a string"), nSql, nOperation);
						ThrowException(Exception::Error(String::New(sError)));
						bOK = false;
						break;
					}

					CString sOperationName = ::AsCString(vOperationName->ToString());

					if (sOperationName == "edit")
					{
						if (!vOldRecord->IsObject())
						{
							CString sError;
							sError.Format(_T("'updateDatabase' function, item %d, operation %d, field 'oldRecord' not found"), nSql, nOperation);
							ThrowException(Exception::Error(String::New(sError)));
							bOK = false;
							break;
						}

						if (!vNewRecord->IsObject())
						{
							CString sError;
							sError.Format(_T("'updateDatabase' function, item %d, operation %d, field 'newRecord' not found"), nSql, nOperation);
							ThrowException(Exception::Error(String::New(sError)));
							bOK = false;
							break;
						}

						Handle<Object> oOldRecord = vOldRecord->ToObject();
						Handle<Object> oNewRecord = vNewRecord->ToObject();

						// Let's go looking for the auto-increment field.  I'd rather be looking for the primary key,
						// but let's face it - I'd rather not be using COM, ADO and JET in the first place!

						CString sAutoIncrementFieldName;

						for (long nFld = 0; nFld < rs->Fields->GetCount(); ++nFld)
						{
							ADODB::FieldPtr fld = rs->Fields->GetItem(nFld);
							_variant_t vt = fld->GetProperties()->GetItem("ISAUTOINCREMENT")->GetValue();
							if (vt.vt == VT_BOOL && vt.boolVal == VARIANT_TRUE)
							{
								sAutoIncrementFieldName = (LPCSTR)fld->GetName();
							}
						}

						if (sAutoIncrementFieldName == "")
						{
							CString sError;
							sError.Format(_T("Auto increment field not found in recordset '%s'"), sQuery);
							oReturnValue->Set(String::New("Error"), String::New(sError));
							bOK = false;
							break;
						}

						Handle<Value> vField = oOldRecord->Get(String::New(sAutoIncrementFieldName));
						int nAutoIncrementValue = vField->Int32Value();

						_variant_t arrKeyValues[1];
						arrKeyValues[0] = nAutoIncrementValue;

						rs->Seek(arrKeyValues, ADODB::adSeekFirstEQ);
					}
					else
					{
						CString sError;
						sError.Format(_T("'updateDatabase' function, item %d, operation %d, operation name '%s' not recognised"), nSql, nOperation, sOperationName);
						ThrowException(Exception::Error(String::New(sError)));
						bOK = false;
						break;
					}
				}

				rs->Close();
			}
			catch(_com_error &e)
			{
				if (bOK)
				{
					oReturnValue->Set(String::New("Error"), String::New(e.Description()));
					bOK = false;
				}
			}
			catch(...)
			{
				if (bOK)
				{
					oReturnValue->Set(String::New("Error"), String::New("Unidentified exception"));
					bOK = false;
				}
			}
		}

		if (bOK == false)
		{
			break;
		}
	}

	try
	{
		if (bOK)
		{
			db->CommitTrans();
		}
		else
		{
			db->RollbackTrans();
		}

		db->Close();
	}
	catch(_com_error &e)
	{
		oReturnValue->Set(String::New("Error"), String::New(e.Description()));
	}
	catch(...)
	{
		oReturnValue->Set(String::New("Error"), String::New("Unidentified exception"));
	}

	return scope.Close(oReturnValue);
}

//
// getIndices
//
Handle<Value> getIndices(const Arguments& args)
{
	HandleScope scope;

	if (args.Length() != 1 || args[0]->IsString() == false)
	{
		ThrowException(Exception::Error(String::New("'getIndices' function expected one argument, which should be a database filename string")));
		return scope.Close(Undefined());
	}

	CString sDatabaseFilename = ::AsCString(args[0]->ToString());

	Handle<Object> oRoot = Object::New();

	try
	{
		ADODB::_ConnectionPtr db("ADODB.Connection");
		db->Provider = "Microsoft.Jet.OLEDB.4.0";
		db->Open((LPCTSTR)sDatabaseFilename, "", "", 0);

		ADODB::_RecordsetPtr rs = db->OpenSchema(ADODB::adSchemaIndexes);

		PopulateFromRecordset(0, 0, 1000, true, rs, oRoot);

		rs->Close();
		db->Close();
	}
	catch(_com_error &e)
	{
		oRoot->Set(String::New("Error"), String::New(e.Description()));
	}
	catch(...)
	{
		oRoot->Set(String::New("Error"), String::New("Unidentified exception"));
	}

	return scope.Close(oRoot);
}

//
// runSql
//
Handle<Value> runSql(const Arguments& args)
{
	HandleScope scope;

	if (args.Length() != 2 || args[0]->IsString() == false || args[1]->IsArray() == false)
	{
		ThrowException(Exception::Error(String::New("'runSql' function expected two arguments, a database filename string, and an array of SQL statement strings")));
		return scope.Close(Undefined());
	}

	CString sDatabaseFilename = ::AsCString(args[0]->ToString());
	Handle<Array> arrSql(Array::Cast(*args[1]->ToObject()));

	try
	{
		ADODB::_ConnectionPtr db("ADODB.Connection");
		db->Provider = "Microsoft.Jet.OLEDB.4.0";
		db->Open((LPCTSTR)sDatabaseFilename, "", "", 0);

		for (UINT n = 0; n < arrSql->Length(); ++n)
		{
			Local<Value> v = arrSql->Get(n);
			if (v->IsString())
			{
				CString sSql = ::AsCString(v);
                db->Execute(_bstr_t(sSql), NULL, 0);
			}
			else
			{
				CString sMsg;
				sMsg.Format(_T("'runSql' function found item at array index %d which was is not a string"), n);
				break;
			}
		}

		db->Close();
	}
	catch(_com_error &e)
	{
		CString sMsg;
		sMsg.Format(_T("'runSql' function encountered an error: %s"), e.Description());
		ThrowException(Exception::Error(String::New(sMsg)));
	}
	catch(...)
	{
		ThrowException(Exception::Error(String::New("'runSql' function encountered an unidentified exception")));
	}

	return scope.Close(Undefined());
}

//
// init
//
void init(Handle<Object> exports)
{
	::CoInitialize(NULL);
	exports->Set(String::NewSymbol("selectSql"), FunctionTemplate::New(selectSql)->GetFunction());
	exports->Set(String::NewSymbol("updateDatabase"), FunctionTemplate::New(updateDatabase)->GetFunction());
	exports->Set(String::NewSymbol("getIndices"), FunctionTemplate::New(getIndices)->GetFunction());
	exports->Set(String::NewSymbol("runSql"), FunctionTemplate::New(runSql)->GetFunction());
}

NODE_MODULE(dface, init)
